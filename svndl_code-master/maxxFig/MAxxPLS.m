function rMAxxPLS = MAxxPLS( aY, aNCond, aNPerm )[ tEPB, tSV, tCondB ] = SVDDev( aY, aNCond ); % tEPB = Evoked Potential Basis; rSV = Singular Values; rCondB = Condition BasistNPerm = aNPerm;tSVPVal = SVDPermutationTest( aY, tSV, tCondB, tNPerm );tNBootSamp = aNPerm;[ tEPBStErr, tCondBStErr ] = SVDBootstrapTest( aY, tCondB, tNBootSamp );rMAxxPLS.EPB = tEPB;rMAxxPLS.SV = tSV;rMAxxPLS.CondB = tCondB;rMAxxPLS.SVPVal = tSVPVal;rMAxxPLS.EPBStErr = tEPBStErr;rMAxxPLS.CondBStErr = tCondBStErr;function [ rEPB, rSV, rCondB ] = SVDDev( aY, aNCond )% Singular value decomposition of deviations of condition means (over subjects) from grand meantNSamp = size( aY, 1 );tNSubj = size( aY, 2 ) / aNCond;tCondMean = squeeze( mean( reshape( aY, tNSamp, tNSubj, aNCond ), 2 ) ); % condition means (over subjects), squeezed to tNSamp x tNCondtCondDev = tCondMean - repmat( mean( tCondMean, 2 ), 1, aNCond ); % deviation of each condition mean from mean over conditions[ rEPB, rSV, rCondB ] = svd( tCondDev, 0 ); % rEPB = Evoked Potential Basis; rSV = Singular Values; rCondB = Condition Basisfunction rSVPVal = SVDPermutationTest( aY, aSV, aCondB, aNPerm)aSV = diag( aSV ); % vector shape convenient for subsequent comparison with procrustes transformed SVs from permuted datarSVPVal = zeros( size( aSV ) ); % proportion of SV from permuted data >= actual SV; accumulates hits on each pass through permutation looptNCond = length( aSV );tNSubj = size( aY, 2 ) / tNCond;tPermSubjConds = PermSubjConds( tNCond, tNSubj, aNPerm ); % see function comments belowhWaitBar = waitbar(0,'Permuting conditions within subject for significance of singular values...');for iPerm = 1:aNPerm	[ tEPB, tSV, tCondB ] = SVDDev( aY( :, tPermSubjConds( :, iPerm ) ), tNCond ); % compute SVD for this permutation    tCondB = tCondB * tSV; % apply singular values to de-normalize basis for this permutation    tCondB = tCondB * ProcrustesTransform( aCondB, tCondB ); % transform minimizes difference between condition bases for this permuation and actual data    tSV = sqrt( sum( tCondB .^ 2 ) ); % compute new SVs, i.e., factors that will re-normalize transformed basis    rSVPVal = rSVPVal + ( tSV' >= aSV ); % accumulate count of hits where permuted SV greater than actual SV.	waitbar( iPerm / aNPerm );endclose( hWaitBar );rSVPVal = rSVPVal / aNPerm; % convert from count to proportion of hitsfunction[ rPermSubjConds ] = PermSubjConds( aNCond, aNSub, aNPerm )% create ( aNCond * aNSub )-by-aNPerm matrix of column subscripts representing permutations of % condition for each subject in a matrix where subjects are nested within condition rPermSubjConds = zeros( aNSub * aNCond, aNPerm );for iPerm = 1:aNPerm   	for iSub = 1:aNSub		rPermSubjConds( iSub:aNSub:end, iPerm ) = ( randperm( aNCond )' - 1 ) * aNSub + iSub;	endendfunction Q = ProcrustesTransform( X, Y )% Q minimizes trace( ( X - YQ )' * ( X - YQ ) ), i.e., the sum-squared difference between X and YQ[ tU, tS, tV ] = svd( X' * Y );Q = tV * tU';function [ rEPBStErr, rCondBStErr ] = SVDBootstrapTest( aY, aCondB, aNBootSamp )tNSamp = size( aY, 1 );tNCond = size( aCondB, 1 );tNSubj = size( aY, 2 ) / tNCond;tBootStrapSubjects = BootStrapSubjects( tNSubj, tNCond, aNBootSamp);tEPBSum = zeros( tNSamp, tNCond ); % accumulator for calculation of Evoked Potential Basis standard errortEPBSumSq = zeros( tNSamp, tNCond ); % accumulator for calculation of Evoked Potential Basis standard errortCondBSum = zeros( size( aCondB ) ); % accumulator for calculation of Condition Basis standard errortCondBSumSq = zeros( size( aCondB ) ); % accumulator for calculation of Condition Basis standard errorh = waitbar( 0, 'Bootstrap resampling for standard errors of bases...' );for iBootSamp = 1:aNBootSamp	[ tEPB, tSV, tCondB ] = SVDDev( aY( :, tBootStrapSubjects( :, iBootSamp ) ), tNCond ); % compute SVD for this boot sample	tQ = ProcrustesTransform( aCondB, tCondB ); % tQ minimizes difference between condition bases for this boot sample and actual data    tEPB = tEPB * tSV * tQ; % apply singular values to de-normalize basis for this boot sample, then apply Procrustes transform%     tEPB = tEPB * tSV; % apply singular values to de-normalize basis for this boot sample, no Procrustes transform	tEPBSum = tEPBSum + tEPB;	tEPBSumSq = tEPBSumSq + tEPB .^ 2;    tCondB = tCondB * tSV * tQ; % apply singular values to de-normalize basis for this boot sample, then apply Procrustes transform%     tCondB = tCondB * tSV; % apply singular values to de-normalize basis for this boot sample, No Procrustes transform	tCondBSum = tCondBSum + tCondB;	tCondBSumSq = tCondBSumSq + tCondB .^ 2;	waitbar( iBootSamp / aNBootSamp );endclose( h );tEPBSum2 = ( ( tEPBSum .^ 2 ) / aNBootSamp );rEPBStErr = sqrt( ( tEPBSumSq - tEPBSum2 ) / ( aNBootSamp - 1 ) );tCondBSum2 = ( ( tCondBSum .^ 2 ) / aNBootSamp );rCondBStErr = sqrt( ( tCondBSumSq - tCondBSum2 ) / ( aNBootSamp - 1 ) );function rBootStrapSubjects = BootStrapSubjects( aNSub, aNCond, aNBootSamples )for iBootSample = 1:aNBootSamples	tBootSample = floor( rand( aNSub, 1 ) * aNSub ) + 1;	tNUniqueSamples = length( unique( tBootSample ) );	while( tNUniqueSamples < aNSub / 2 )		tBootSample = floor( rand( aNSub, 1 ) * aNSub ) + 1;		tNUniqueSamples = length( unique( tBootSample ) );	end	rBootStrapSubjects( :, iBootSample ) = repmat( tBootSample, aNCond, 1 ) + kron( [ 0:( aNCond - 1 ) ]', ones( aNSub, 1 ) ) * aNSub;end% If you are doing svd on cross covariance matrix...% tX = ContMat( tNCond, tNSubj );% tYCovX = YCovX( tY, tX );% where...% % function rC = ContMat( aNCond, aNSub )% % if we use cross correlation matrix, we use...% rC = kron( [ eye( aNCond - 1 ); zeros( 1, aNCond - 1 ) ] - [ zeros( 1, aNCond - 1 ); eye( aNCond - 1 ) ], ones( aNSub, 1 ) );% % otherwise, if we use cross covariance matrix, we must normalize contrasts...% rC = orth( rC );% % function rYCovX = YCovX( aY, aX )% % if we use normalized contrasts, we use raw cross covariance matrix...% rYCovX = ( ( aY - repmat( mean( aY, 2 ), 1, size( aY, 2 ) ) ) * ( aX - repmat( mean( aX ), size( aX, 1 ), 1 ) ) ) / ( size( aY, 2 ) - 1 );% % otherwise if we use unnormalized contrasts, we must convert to cross correlation matrix...% % rYCovX = rYCovX ./ sqrt( diag( cov( aY' ) )* diag( cov( aX ) )' );% % An example of a testing scenario to compare results and speed...% tic% rand( 'state', 42267 );% [ sperm1,sprob1,designlvperm1,originalerplv1,erpse1,bootratioerp1,originaldesignlv1,designse1 ] = NancysDesignPLS;% toc% % clc;% disp( 'Unequal Results...' );% a = sum( sum( sperm1 ~= diag( tSV ) ) )% b = sum( sum( sprob1 ~= tSVPVal ) )% c = sum( sum( designlvperm1 ~= tCondB ) )% d = sum( sum( originalerplv1 ~= ( tEPB * tSV ) ) )% e = sum( sum( erpse1 ~= tEPBStErr ) )% f = sum( sum( bootratioerp1 ~= ( ( tEPB * tSV ) ./ tEPBStErr ) ) )% g = sum( sum( originaldesignlv1 ~= ( tCondB * tSV ) ) )% h = sum( sum( designse1 ~= tCondBStErr ) )