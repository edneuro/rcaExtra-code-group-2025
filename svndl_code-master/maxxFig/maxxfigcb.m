% maxxfigcb.m v.6% reorganize significance testing functions% develop testing spectra using t-circ% develop testing between time/freq slices, and swapping cnd and chanfunction maxxfigcb( aStr )global gMF;% typical user interface callback property: 'maxxfigcb(get(gcbo,''Tag''))'switch aStrcase 'debug'	tLVSS = 2; % latent variable subscript	[ tNT, tNCh, tNSbj ] = size( gMF.Data{1}.R );	tT  = gMF.Data{1}.T;	tTDes = 728.5; % given desired time point...	% now find the index iT corresponding to the nearest actual time sample	iT = abs( tT - tTDes ) == min( abs( tT - tTDes ) );	tEPB = reshape( gMF.MAxxPLS.EPB( :, tLVSS ) * gMF.MAxxPLS.SV( tLVSS, tLVSS ), tNT, tNCh ); % Evoked potential basis for this LV...	tEPBT = tEPB( iT, : )'; % at time = iT	tEPBStErr = reshape( gMF.MAxxPLS.EPBStErr( :, tLVSS ), tNT, tNCh ); % standard error of EPB...	tEPBTStErr = tEPBStErr( iT, : )'; % at time = iT	tSigR = norminv( 1 - 0.025 / tNCh / tNT ); % z-score corresponding to 2-tailed p=0.05, corrected for tNCh and tNT	tSigIndx = abs( tEPBT ) > tSigR * tEPBTStErr;		tH = topoplot( tEPBT, 'Time', tSigIndx, 'LabelsOn', 'HCN', logical( ones( 128, 1 ) ) );	set( tH, 'Name', [ gMF.MatFN(1:findstr('.mat',gMF.MatFN)-1) ', LV' num2str(tLVSS) ': t = ' num2str( tTDes ) ] );% 	for iCnd = [ 2 3 6 7 10 11 14 15 18 19 22 23 24 26 31 ]; % for CH's kanizsa 4GrpAllGIGforPub.mat% % 	for iCnd = [ 3:8 ]; % for CH's kanizsa NormKanBinoMono.mat% 		gMF.Data{ iCnd }.R = cat( 1, gMF.Data{ iCnd }.R( (end/2 + 1):end, :, : ), gMF.Data{ iCnd }.R( 1:(end/2), :, : ) );% 	end% 	montage( 'EyeChan' );% 	warndlg( 'Debug mode: no debug script enabled' )% 	warndlg( 'Debug mode: axxfilter' )% 	axxfilter;% 	warndlg( 'Debug mode: ImportRBTX' )%	ImportRBTX( 'Fig' ); % only use this when importing Figure region reconstructions%   	ImportRBTX( 'Back' ); % only use this when importing Background region reconstructions% % 	warndlg( 'Debug mode: TxposeForFreqMapComp' )% %	TxposeAndAvgRBTX;  % only use these when transposing to compare ROI's% % 	montage( 'OccipitalTransept' );  % do this after normalizing to mean of cond,chan within frequency% 	TxposeForFreqMapComp;  % only use these when transposing to compare freq maps% 	defaultsigindx;	% % 	warndlg( 'Debug mode: ExportPLSLV2EMSE( 2 )' )% 	ExportPLSLV2EMSE( 1 );% 	ExportPLSLV2EMSE( 2 );% 	ExportPLSLV2EMSE( 3 );% 	warndlg( 'Debug mode: Verify average referencing' )% 	figure;% 	tT =  gMF.Data{1}.T;% 	tD = gMF.Data{1}.R(:,:,1);% 	plot( tT, tD(:,1), 'k-', tT, tD(:,1) - mean( tD, 2 ) + .1, 'b-' );% 	warndlg( 'Debug mode: Plot map significance' )% 	tFigData = mean( gMF.Data{ 1, 1 }.R( 1:128, 1, : ), 3 ); % must use explicit 1:128; topoplot can't handle 129th chan% 	tBakData = mean( gMF.Data{ 1, 2 }.R( 1:128, 1, : ), 3 );% %  	tSigIndx = gMF.SigIndxRCV{ 1, 2 }( :, 1 ); % to show results of permutation test between conds 1 and 2.% 	tSigIndx = logical( ones( 128, 1 ) ); % to show all chans% %	tSigIndx = logical( zeros( 128, 1 ) ); % to show no chans% 	topoplot( tFigData, 'Spline', 'Freq', tSigIndx, 'LabelsOn', 'HCN' );% 	topoplot( tBakData, 'Spline', 'Freq', tSigIndx, 'LabelsOn', 'HCN' );% %	warndlg( 'Debug mode: Maxima analysis' )% % 	iSbj = [ 1:6 8 9 ];% 	tD( :, :, 1 ) = squeeze( gMF.Data{ gMF.iCond1 }.A( 11, 1:128, : ) ); % 2F1, Figure region response% 	tD( :, :, 2 ) = squeeze( gMF.Data{ gMF.iCond2 }.A( 13, 1:128, : ) ); % 2F2, Background region response% 	[ tZM, tP ] = comparemapmax( tD );% 	disp( [ 'Mean Z diff = ' num2str( tZM ) ', p = ' num2str( tP ) ] );% %	warndlg( 'Debug mode: Maxima jackknife analysis' )% 	% first, do the ith-deleted estimates% 	tNSbj = size( gMF.Data{ gMF.iCond1 }.A, 3 ); % the number of subjects% 	tiDel = logical( ones( tNSbj ) - ones( tNSbj ) .* diag( ones( tNSbj, 1 ) ) );% 	for iSbj = 1:tNSbj% 		ti = tiDel( :, iSbj );% 		tD( :, :, 1 ) = squeeze( gMF.Data{ gMF.iCond1 }.A( 11, 1:128, ti ) ); % 2F1, Figure region response, ith-deleted% 		tD( :, :, 2 ) = squeeze( gMF.Data{ gMF.iCond2 }.A( 11, 1:128, ti ) ); % 2F2, Background region response, ith-deleted% 		[ tZM(iSbj), tP(iSbj) ] = comparemapmax( tD );% 	end% 	tZMSE = sqrt( ( tNSbj - 1 ) * sum( ( tZM - mean( tZM ) ) .^ 2 ) / tNSbj );% 	% now do the full group% 	tDall( :, :, 1 ) = squeeze( gMF.Data{ gMF.iCond1 }.A( 11, 1:128, : ) ); % 2F1, Figure region response, all subs% 	tDall( :, :, 2 ) = squeeze( gMF.Data{ gMF.iCond2 }.A( 11, 1:128, : ) ); % 2F2, Background region response, all subs% 	[ tZMall, tPall ] = comparemapmax( tDall );% 	disp( [ 'Mean Z diff = ' num2str( tZMall ) ' ± ' num2str( tZMSE ) ', p = ' num2str( 1 - normcdf( tZMall / tZMSE ) ) ] );	case 'AxxFilter'			axxfilter;case 'ChanSlider'			ChanSlider;case 'Constructor'			Constructor;case 'Destructor'			Destructor;case 'ClearNormAxes'			ClearWaveAxes;case 'ClearWaveAxes'			ClearWaveAxes;case 'CondSingle'			CondSingle;case 'CondDouble'			CondDouble;case 'ExportRMSDiff'			ExportRMSDiff;case 'ExportPLSDataTableA'			ExportPLSDataTable( 'A' );case 'ExportPLSDataTableR'			ExportPLSDataTable( 'R' );case 'PlotNormMean'% 			PlotWaveMean( 'N' );			PlotWaveform( 'N', 'MO' ); % MO SO MD SDcase 'PlotNormMeanDiff'			PlotWaveform( 'N', 'MD' ); % MO SO MD SDcase 'PlotNormSubjects'			PlotWaveform( 'N', 'SO' ); % MO SO MD SDcase 'PlotNormSubjectsDiff'			PlotWaveform( 'N', 'SD' ); % MO SO MD SDcase 'PlotNormSigOmniRuns'			PlotSig( 'N', 'O', 'R', 'T' );case 'PlotNormSigOmniVals'			PlotSig( 'N', 'O', 'V', 'T' );case 'PlotNormSigChanRuns'			PlotSig( 'N', 'C', 'R', 'T' );case 'PlotNormSigChanVals'			PlotSig( 'N', 'C', 'V', 'T' );case 'PlotNormTVals'			PlotTVals( 'N' );case 'PlotPLS'			PlotPLS;case 'PlotWaveMean'			PlotWaveform( 'R', 'MO' ); % MO SO MD SDcase 'PlotWaveMeanDiff'			PlotWaveform( 'R', 'MD' ); % MO SO MD SDcase 'PlotWaveSubjects'			PlotWaveform( 'R', 'SO' ); % MO SO MD SDcase 'PlotWaveSubjectsDiff'			PlotWaveform( 'R', 'SD' ); % MO SO MD SD% case 'PlotWaveSig'% 			PlotSig( 'R', 'O', 'R', 'T' );case 'PlotWaveSigOmniRuns'			PlotSig( 'R', 'O', 'R', 'T' );case 'PlotWaveSigOmniVals'			PlotSig( 'R', 'O', 'V', 'T' );case 'PlotWaveSigChanRuns'			PlotSig( 'R', 'C', 'R', 'T' );case 'PlotWaveSigChanVals'			PlotSig( 'R', 'C', 'V', 'T' );case 'PlotWaveTVals'			PlotTVals( 'R' );case 'PlotWaveFDRVals'            PlotFDRTVals( 'R' );case 'PlotSpecVector'			PlotSpecVector;case 'PlotSpecScalar'			PlotSpecScalar;case 'ProjOpenMat'			ProjOpenMat;case 'ProjOpenTxt'			ProjOpenTxt;case 'ResetSpecXLim'			ResetSpecXLim;case 'ResetWaveYLim'			ResetWaveYLim;case 'SplitData'			splitdata;otherwiseendfunction axxfilter()% Matlab implementation of PD IFFT algorithm with filtering% Original version with comments in Firewire117:_inactive:matcode:PDTools:PDIFFT.mglobal gMF;% these three variables must be tested and updated (if needed) for each condition% iF = [ 0 0 ];% tNFr = 0;% tNT = 0;iF = [ gMF.Data{1}.i1F1 gMF.Data{1}.i1F2 ];tNFr = size( gMF.Data{1}.Cos, 1 );[ tNT, tNCh, tNS ] = size( gMF.Data{ 1 }.R );[ tFilter tFilterName ] = GetFilter( iF, tNFr - 1 ); % -1 adjusts for unwanted DC componentfor iC = 1:length( gMF.casCond )	% get filter spec parameters for the new condition	iFnew = [ gMF.Data{iC}.i1F1 gMF.Data{iC}.i1F2 ];	tNFrNew = size( gMF.Data{iC}.Cos, 1 );	[ tNTNew, tNCh, tNS ] = size( gMF.Data{ iC }.R );	if iC == 1 | any( iF ~= iFnew ) | tNFr ~= tNFrNew | tNT ~= tNTNew; % new parameters for filter specification...		% rebuild filter resources		iF = iFnew;		tNFr = tNFrNew;		tNT = tNTNew;		[ tFilter tFilterName ] = GetFilter( iF, tNFr - 1, tFilterName ); % -1 adjusts for unwanted DC component		tNRC = gcd( iF(1), iF(2) );		tNT2 = tNRC * tNT; % set this so analysis epoch is 2 sec, corresponding to dFHz = 0.5		tIT = ( [ 1:tNT2 ] - 1 ); % for math we need zero-based vector of time points		tT = tIT / tNT2;		tFBCos = cos( 2 * pi * tT ); % fundamental Fourier basis functions		tFBSin = sin( 2 * pi * tT );		tH = [ 1:(tNFr-1) ]'; % harmonic coefficients, leaving off DC component% now build nFr x nT matrix of indices into tFB for each harmonic% by computing outer product of vector of harmonic coefficients% first row simply iterates through each time point,% second row iterates through every other time point, third row through every third point, &c.% modulus by number of time points makes the indices in tH * tIT  greater than nT wrap around properly% adding 1 returns indices to 1-based matlab indexing		tIH = mod( tH( tFilter ) * tIT, tNT2 ) + 1;	end	gMF.Data{ iC }.Filter = tFilter;	gMF.Data{ iC }.FilterName = tFilterName;	for iCh = 1:tNCh		for iS = 1:tNS			% now do element-wise product between basis functions and repmat matrix of waveform,			% then compute sum and normalize			tWCos = sum( tFBCos( tIH ) .* repmat( gMF.Data{iC}.Cos( tFilter+1, iCh, iS ), 1, tNT2 ), 1 )'; % +1 adjusts for unwanted DC component			tWSin = sum( tFBSin( tIH ) .* repmat( gMF.Data{iC}.Sin( tFilter+1, iCh, iS ), 1, tNT2 ), 1 )';			gMF.Data{iC}.R( :, iCh, iS ) = mean( reshape( tWCos + tWSin, tNT2 / tNRC, tNRC ), 2 );		end	endendfunction ChanSlider()% reset the range of channel data indices selected for plotting% hard coding for 128 channels should be generalized for other values greater than 8...set( gcbo, 'userdata', round( [ 1:8 ] + ( 1 - get( gcbo, 'Value' ) ) * ( 128 - 8 ) ) );ClearWaveAxes;clearspecaxes;% disp( get( gcbo, 'userdata' ) );function rChDI = ChanDI( iCh )% called by plotting functions to determine the channel data index, ChDI,% corresponding to a plot axis index, iCh, given current state of channel sliderglobal gMF;if( strcmp( get( findobj( 'tag', 'ChanSlider' ), 'enable' ), 'on' ) )	tChDIs = get( findobj( 'tag', 'ChanSlider' ), 'userdata' );else	tChDIs = [ 1:gMF.nChD ];endrChDI = tChDIs( iCh );function tChPos = ChPos( tNetType )if strcmp( tNetType, 'HCN' )	tChPos = ChPosHCN;else % implicitly...	tChPos = ChPosGSN;endfunction tChPos = ChPosHCN()% obtained by uncommenting code at bottom of VESchemeHCN_128::BuildVectorXYtChPos = [ ...% 0 0.5 0.5; ...55 0.5 0.4375; ...80 0.559441 0.480686; ...106 0.536737 0.550564; ...7 0.463263 0.550564; ...31 0.440559 0.480686; ...79 0.573473 0.398873; ...87 0.618882 0.461373; ...105 0.618882 0.538627; ...112 0.573473 0.601127; ...6 0.5 0.625; ...13 0.426527 0.601127; ...30 0.381118 0.538627; ...37 0.381118 0.461373; ...54 0.426527 0.398873; ...62 0.5 0.3125; ...78 0.576263 0.32871; ...86 0.63934 0.374538; ...93 0.678323 0.442059; ...104 0.686473 0.519599; ...111 0.66238 0.59375; ...118 0.61021 0.651691; ...5 0.538983 0.683403; ...12 0.461017 0.683403; ...20 0.38979 0.651691; ...29 0.33762 0.59375; ...36 0.313527 0.519599; ...42 0.321677 0.442059; ...53 0.36066 0.374538; ...61 0.423737 0.32871; ...72 0.5 0.25; ...77 0.577254 0.262236; ...85 0.646946 0.297746; ...92 0.702254 0.353054; ...98 0.737764 0.422746; ...103 0.75 0.5; ...110 0.737764 0.577254; ...117 0.702254 0.646946; ...124 0.646946 0.702254; ...4 0.577254 0.737764; ...11 0.5 0.75; ...19 0.422746 0.737764; ...24 0.353054 0.702254; ...28 0.297746 0.646946; ...35 0.262236 0.577254; ...41 0.25 0.5; ...47 0.262236 0.422746; ...52 0.297746 0.353054; ...60 0.353054 0.297746; ...67 0.422746 0.262236; ...76 0.547321 0.201224; ...84 0.637332 0.230471; ...91 0.7139 0.2861; ...97 0.769529 0.362668; ...102 0.798776 0.452679; ...109 0.798776 0.547321; ...116 0.769529 0.637332; ...123 0.7139 0.7139; ...3 0.638901 0.772608; ...10 0.567774 0.803205; ...16 0.5 0.8125; ...18 0.432226 0.803205; ...23 0.361099 0.772608; ...27 0.2861 0.7139; ...34 0.230471 0.637332; ...40 0.201224 0.547321; ...46 0.201224 0.452679; ...51 0.230471 0.362668; ...59 0.2861 0.2861; ...66 0.362668 0.230471; ...71 0.452679 0.201224; ...75 0.5 0.1575; ...83 0.605838 0.174263; ...90 0.701316 0.222912; ...96 0.777088 0.298684; ...101 0.825737 0.394162; ...108 0.8425 0.5; ...115 0.825737 0.605838; ...122 0.777088 0.701316; ...2 0.703 0.779406; ...9 0.611906 0.844411; ...15 0.5 0.8725; ...22 0.388094 0.844411; ...26 0.297 0.779406; ...33 0.222912 0.701316; ...39 0.174263 0.605838; ...45 0.1575 0.5; ...50 0.174263 0.394162; ...58 0.222912 0.298684; ...65 0.298684 0.222912; ...70 0.394162 0.174263; ...82 0.559054 0.127148; ...89 0.671381 0.163645; ...95 0.766933 0.233067; ...100 0.836355 0.328619; ...114 0.872852 0.559054; ...121 0.836355 0.671381; ...1 0.766933 0.766933; ...8 0.673891 0.84128; ...14 0.561318 0.887146; ...21 0.438682 0.887146; ...25 0.326109 0.84128; ...32 0.233067 0.766933; ...38 0.163645 0.671381; ...44 0.127148 0.559054; ...57 0.163645 0.328619; ...64 0.233067 0.233067; ...69 0.328619 0.163645; ...74 0.440946 0.127148; ...81 0.5 0.09; ...88 0.626697 0.110067; ...94 0.740992 0.168303; ...99 0.831697 0.259008; ...107 0.889933 0.373303; ...113 0.91 0.5; ...120 0.889933 0.626697; ...125 0.831697 0.740992; ...126 0.740992 0.831697; ...17 0.5 0.94; ...127 0.259008 0.831697; ...128 0.168303 0.740992; ...43 0.110067 0.626697; ...49 0.09 0.5; ...56 0.110067 0.373303; ...63 0.168303 0.259008; ...68 0.259008 0.168303; ...73 0.373303 0.110067; ...119 0.941991 0.570004; ...48 0.0580095 0.570004; ...% 129 0.5 0.5; ...];[ tY, tYI ] = sort( tChPos( :, 1 ) );tChPos = tChPos( tYI, 2:3 );function tChPos = ChPosGSN()% obtained by uncommenting code at bottom of VESchemeGSN_128::BuildVectorXYtChPos = [ ...% 0 0.5 0.5; ...55 0.5 0.4375; ...81 0.559441 0.480686; ...107 0.536737 0.550564; ...7 0.463263 0.550564; ...32 0.440559 0.480686; ...62 0.5 0.375; ...80 0.573473 0.398873; ...88 0.618882 0.461373; ...106 0.618882 0.538627; ...113 0.573473 0.601127; ...6 0.5 0.625; ...13 0.426527 0.601127; ...31 0.381118 0.538627; ...38 0.381118 0.461373; ...54 0.426527 0.398873; ...68 0.5 0.3125; ...79 0.576263 0.32871; ...87 0.63934 0.374538; ...94 0.678323 0.442059; ...105 0.686473 0.519599; ...112 0.66238 0.59375; ...119 0.61021 0.651691; ...5 0.538983 0.683403; ...12 0.461017 0.683403; ...21 0.38979 0.651691; ...30 0.33762 0.59375; ...37 0.313527 0.519599; ...43 0.321677 0.442059; ...53 0.36066 0.374538; ...61 0.423737 0.32871; ...73 0.5 0.25; ...78 0.577254 0.262236; ...86 0.646946 0.297746; ...93 0.702254 0.353054; ...99 0.737764 0.422746; ...104 0.75 0.5; ...111 0.737764 0.577254; ...118 0.702254 0.646946; ...124 0.646946 0.702254; ...4 0.577254 0.737764; ...11 0.5 0.75; ...20 0.422746 0.737764; ...25 0.353054 0.702254; ...29 0.297746 0.646946; ...36 0.262236 0.577254; ...42 0.25 0.5; ...48 0.262236 0.422746; ...52 0.297746 0.353054; ...60 0.353054 0.297746; ...67 0.422746 0.262236; ...77 0.546576 0.19099; ...85 0.635589 0.218447; ...92 0.712554 0.270921; ...98 0.770633 0.34375; ...103 0.804665 0.430462; ...110 0.811626 0.523353; ...117 0.790898 0.614169; ...123 0.744322 0.694841; ...3 0.676038 0.7582; ...10 0.592111 0.798617; ...16 0.5 0.8125; ...19 0.407889 0.798617; ...24 0.323962 0.7582; ...28 0.255678 0.694841; ...35 0.209102 0.614169; ...41 0.188374 0.523353; ...47 0.195335 0.430462; ...51 0.229367 0.34375; ...59 0.287446 0.270921; ...66 0.364411 0.218447; ...72 0.453424 0.19099; ...76 0.5 0.145; ...84 0.604638 0.160772; ...91 0.699979 0.206685; ...97 0.77755 0.278661; ...102 0.83046 0.370304; ...109 0.854007 0.473471; ...116 0.846099 0.578995; ...122 0.807439 0.6775; ...2 0.741461 0.760233; ...9 0.654029 0.819844; ...15 0.55291 0.851035; ...18 0.44709 0.851035; ...23 0.345971 0.819844; ...27 0.258539 0.760233; ...34 0.192561 0.6775; ...40 0.153901 0.578995; ...46 0.145993 0.473471; ...50 0.16954 0.370304; ...58 0.22245 0.278661; ...65 0.300021 0.206685; ...71 0.395362 0.160772; ...83 0.558499 0.111884; ...90 0.670299 0.14637; ...96 0.766968 0.212277; ...101 0.839915 0.30375; ...115 0.891402 0.529332; ...121 0.865368 0.643396; ...1 0.806869 0.74472; ...8 0.721103 0.824299; ...14 0.615691 0.875062; ...22 0.384309 0.875062; ...26 0.278897 0.824299; ...33 0.193131 0.74472; ...39 0.134632 0.643396; ...45 0.108598 0.529332; ...57 0.160085 0.30375; ...64 0.233032 0.212277; ...70 0.329701 0.14637; ...75 0.441501 0.111884; ...82 0.5 0.08; ...89 0.623797 0.0986594; ...95 0.736594 0.15298; ...100 0.828369 0.238134; ...108 0.890967 0.346557; ...114 0.918826 0.468613; ...120 0.90947 0.593459; ...125 0.863731 0.71; ...126 0.785673 0.807882; ...17 0.5 0.92; ...127 0.214327 0.807882; ...128 0.136269 0.71; ...44 0.0905303 0.593459; ...49 0.0811744 0.468613; ...56 0.109033 0.346557; ...63 0.171631 0.238134; ...69 0.263406 0.15298; ...74 0.376203 0.0986594; ...% 129 0.5 0.5; ...];[ tY, tYI ] = sort( tChPos( :, 1 ) );tChPos = tChPos( tYI, 2:3 );function clearspecaxes()global gMF;for( iCh = 1:gMF.nChP )	subplot( gMF.SpecPlot( iCh ) );	cla;endfunction ClearWaveAxes()global gMF;for( iCh = 1:gMF.nChP )	subplot( gMF.WavePlot( iCh ) );	cla;endsetmenu( 'off', 'PlotWaveSig', 'PlotNormSig', 'ResetWaveYLim' );function CondDouble()global gMF;selectcond( 0 );selectcond( 1 );% readcondfiles( 0 );% readcondfiles( 1 );setmenu( 'on', 'PlotSpecVector','PlotSpecScalar','ResetSpecXLim','ClearWaveAxes','PlotWaveMean','PlotWaveMeanDiff', ...	'PlotWaveSubjects','PlotWaveSubjectsDiff', 'PlotWaveTVals','ClearNormAxes','PlotNormMean','PlotNormMeanDiff','PlotNormSubjects', ...	'PlotNormSubjectsDiff', 'PlotNormTVals','PlotPLS','ExportRMSDiff', 'ExportPLSDataTableR', 'ExportPLSDataTableA' );setmenu( 'off', 'PlotWaveSig', 'PlotNormSig' );if( ( ~iswinsubjcond ) | ( gMF.iCond1 == gMF.iCond2 ) )	setmenu( 'off', 'PlotWaveSubjectsDiff', 'PlotNormSubjectsDiff' );endprepareaxes;function CondSingle()selectcond( 0 );% readcondfiles( 0 );setmenu( 'on', 'PlotSpecVector','PlotSpecScalar','ResetSpecXLim','ClearWaveAxes','PlotWaveMean', ...	'PlotWaveSubjects','PlotPLS','ClearNormAxes','PlotNormMean','PlotNormSubjects', ...	'PlotPLS', ...	'ExportRMSDiff', 'ExportPLSDataTableR', 'ExportPLSDataTableA' );setmenu( 'off','PlotWaveMeanDiff', 'PlotWaveSubjectsDiff','PlotWaveSig', 'PlotWaveTVals', ...				'PlotNormMeanDiff','PlotNormSubjectsDiff', 'PlotNormSig', 'PlotNormTVals' );prepareaxes;function Constructor()global gMF;if( isfield( gMF, 'FN' ) )	Destructor;	global gMF;endgMF.FN = [];gMF.PN = [];gMF.MatFN = [];gMF.MatPN = [];% gMF.nCh = [];gMF.nChD = []; % number of data channelsgMF.nChP = []; % number of channels to plotgMF.casChan = {};gMF.casCond = {};gMF.casSess = {};gMF.Data = {};gMF.iCond1 = 0;gMF.iCond2 = 0;gMF.WavePlot = []; %axis handlesgMF.SpecPlot = [];function createaxes()global gMF;nCh = gMF.nChP;% tH = ( .86 - ( .01 * nCh ) ) / nCh;tH = 0.86 / nCh;tSpecPos = [ .05 .05 + tH * ( nCh - 1 ) .29 tH - 0.01 ];tWavePos = [ .40 .05 + tH * ( nCh - 1 ) .55 tH - 0.01 ];for( iCh = 1:nCh )	gMF.SpecPlot( iCh ) = subplot( 'position', tSpecPos );	hold on;	gMF.WavePlot( iCh ) = subplot( 'position', tWavePos );	hold on;	tSpecPos( 2 ) = tSpecPos( 2 ) - tH;	tWavePos( 2 ) = tWavePos( 2 ) - tH;	if( iCh < nCh )		set( gMF.SpecPlot( iCh ), 'XTickLabel', '' );% 		set( gMF.SpecPlot( iCh ), 'YTickLabel', '' );		set( gMF.WavePlot( iCh ), 'XTickLabel', '' );% 		set( gMF.WavePlot( iCh ), 'YTickLabel', '' );	endendfunction tRefDist = createreferencedistribution( asDataType, aTRuns )global gMF;tNG = length( gMF.casSess{ gMF.iCond1 } ); % number of subjects in the group for condition 1tNSubs = tNG + length( gMF.casSess{ gMF.iCond2 } ); % total number of subjectsif( iswinsubjcond | ( gMF.iCond1 == gMF.iCond2 ) )	tNSubs = tNG;	tNRS = 2^tNSubs; % number of possible within-subject permutations of sign ("number of re-samples")else	tNRS = prod( ( tNSubs - tNG + 1 ):tNSubs ) / prod( 1:tNG ); % number of possible combinationsendtMaxNRS = 200; % use this to set upper limit for maximum number of resamples% tMaxNRS = tNRS; % use this to do 'em allif( tNRS > tMaxNRS )	% choose a random set of the possible perms/combs 	rand('state',sum(100*clock));%	rand('state',422);	iRS = round( tNRS * rand( tMaxNRS, 1 ) );	tNRS = tMaxNRS;else	% do 'em all	iRS = [ 1:tNRS ];end[tNSamples, tNChans, ignore ] = size( getfield( gMF.Data{gMF.iCond1}, asDataType ) );if( iswinsubjcond | ( gMF.iCond1 == gMF.iCond2 ) )	% Create reference distribution of by permuting signs of waveforms for each subject	tIndx = num2bits( iRS, tNSubs ); % sign permutation matrixelse	% Create reference distribution using random combinations of group assignment	tIndx = logical( num2comb( iRS, tNG, tNSubs ) ); % group combination matrixendtRefDist = zeros( tNRS, tNChans );tH = waitbar( 0, 'Creating reference distribution' );for i = 1:tNRS % is 2 to the power of (tNSubs-1) x tNsubs 	tRefDist( i, : ) = max( StatScores( aTRuns, tIndx(i,:) ) );	waitbar( i / tNRS );end % tRefDist is tNPermutations x nCh x 1close( tH );function casChan = channames( aRange )% returns default Ch1, Ch2, &c. channel names used for channel range provided in aRangetNCh = length( aRange );casChan = cell( tNCh, 1 );for iCh = 1:tNCh	casChan{ iCh } = [ 'Ch' num2str( aRange( iCh ) ) ];endfunction [ tZM, tP ] = comparemapmax( tD )% function comparemapmax( tD )% tD is nCh x nSbj x nData(2)tDataType = 'Freq';tSigIndx = logical( zeros( 128, 1 ) ); % to show no chanstNetType = 'HCN';tNSbj = size( tD, 2 );tChanMask = logical( ones( 128, 1 ) ); % Include all channels in topomap comparison...% Toggle the following to mask out channels at the rim of the sensor net.% tChanMask( [ 1 8 14 17 21 25 32 38 43 48 49 56 63 68 73 81 88 94 99 107 113 119 120 121 125:128 ] ) = 0;for iD = 1:2	tHMap( iD ) = topoplot( mean( tD( 1:128, :, iD ), 2 ), tDataType, tSigIndx, 'LabelsOn', tNetType, tChanMask ); % , 3.5, 0 );	for iSbj = 1:tNSbj		[ tTopoMap, tChX, tChY ] = topospline( tD( 1:128, iSbj, iD ), tDataType, tNetType, tChanMask );		topoplot( tD( 1:128, iSbj, iD ), tDataType, tSigIndx, 'LabelsOn', tNetType, tChanMask );		tHarm = { 'Fig', 'Bak' };		title( [ subjname( iD, iSbj ) ' ' tHarm{ iD } ] );		% Find coordinates for maxima		[ tMx, tIMx ] = max( tTopoMap );		[ tMx, tXMx( iD, iSbj ) ] = max( tMx );		tYMx( iD, iSbj ) = tIMx( tXMx( iD, iSbj ) );	endendfor iD = 1:2	figure( tHMap( iD ) );	hold on;	plot( tXMx, tYMx, 'g-' );	plot( tXMx(1,:), tYMx(1,:), 'go' );	plot( tXMx(2,:), tYMx(2,:), 'g.', 'markersize', 18 );endtZSq = diff( tXMx ) .^ 2 + diff( tYMx ) .^ 2;tZM = mean( sqrt( tZSq ) );tZVar = var( sqrt( tZSq ) );tS = sqrt( tZVar * 2 / ( 4 - pi ) ); % mode (not s.d.) parameterizes rayleigh distributiontP = 1 - raylcdf( tZM, tS );function defaultsigindx()global gMF;for iDataType = 'RN'	for iOmnibus = 'OC'		for iTRuns = 'RV'			gMF = setfield( gMF, [ 'SigIndx' iDataType iOmnibus iTRuns ], cell( length( gMF.casCond ) ) );		end	end	gMF = setfield( gMF, [ 'TScoreP' iDataType ], cell( length( gMF.casCond ) ) );endfunction Destructor()global gMF;if( isfield( gMF, 'FN' ) ) % gMF has not been destructed by closing another MAxxFig window	set( findobj( 'Tag', 'ChanSlider' ), 'Enable', 'off', 'UserData', [ 1:8 ] );	if( isfield( gMF.SpecPlot, 'axis' ) )		clearspecaxes;		ClearWaveAxes;	end	if( ~isempty( gMF.MatFN ) ) % no data has been loaded into gMF		tFN = gMF.MatFN;		tPN = gMF.MatPN;		gMF.MatFN = [];		gMF.MatPN = [];		gMF.iCond1 = 0;		gMF.iCond2 = 0;		gMF.WavePlot = []; %axis handles		gMF.SpecPlot = [];		tsAns = questdlg( [ 'Do you want to save ' tFN ], '', 'Yes', 'No', 'Yes' );		switch tsAns		case 'Yes'			tfSaveOK = savegMF( tPN, tFN ); % tfSaveOK == 0 indicates user cancelled or aborted a failed save attempt		case 'No'			tfSaveOK = 1;		otherwise		end	else		tfSaveOK = 1;	end	if( ~tfSaveOK )		gMF.MatFN = tFN;		gMF.MatPN = tPN;		Destructor;	endendclear global gMF;function ExportPLSDataTable( asDataType )% convert gMF.Data{ : }.R or .A into [ tNCond * tNSubs x tNCh * tNSamp ] and save into .mat fileglobal gMF;tNCond = length( gMF.Data );[ tNSamp, tNCh, tNSess ] = size( getfield( gMF.Data{ 1 }, asDataType ) );for iCond = 1:tNCond	PLSDataTable( ( ( iCond - 1 ) * tNSess + 1 ):( iCond * tNSess ), : ) = reshape( getfield( gMF.Data{ iCond }, asDataType ), tNSamp * tNCh, tNSess )';endsave( [ gMF.MatPN 'PLS_' gMF.MatFN ], 'PLSDataTable' );function ExportPLSLV2EMSE( iLV )% Export the Evoked Potential Basis waveform for iLVth latent variable (which is nChan*nSamp x 1)% as a tab-delimited table ( nCh x nSamp ) in ascii format readable by EMSEglobal gMF;[tFID, tMsg ] = fopen( [ 'KanOnOff_LV' num2str( iLV ) '_512.asc' ], 'wt' );tNCh = gMF.nChD; % number of data channelstNS = size( gMF.MAxxPLS.EPB, 1 ) / tNCh; % number of data samples;tNRS = 512; % number to resample totRSLV = resample( gMF.MAxxPLS.EPB( :, iLV ) * gMF.MAxxPLS.SV( iLV, iLV ), tNRS, tNS ); % re-sampled LV (resampled to 512)tFormSpec = [ '%.5e' repmat( '\t%.5e', 1, tNRS - 1 ) '\015\012' ]; % CRLF-terminated format specifier for a channel's worth of data samplestN = fprintf( tFID, tFormSpec, tRSLV );	% vectorized fprintf will transpose and reshape; it iterates down through rows of EPB										% to fill in data samples for each row (i.e., channel) in the file.function ExportRMSDiff()rms = rmsdifference;[ sFN, sPN ] = uiputfile( '*.txt', 'Save Spreadsheet As...' );rms1 = reshape( rms, [ size(rms,2) size(rms,3) ] )';exporttable( num2cell( rms1 ), [ sPN, sFN ], 'w' );function retval = exporttable( casTableIn, sFileName, sFileSpec );%retval = exporttable( casTableIn, sFileName, sFileSpec )[ nRows, nCols ] = size( casTableIn );fid = fopen( sFileName, sFileSpec );for iRow = 1: nRows	for iCol = 1: nCols		if( isempty( casTableIn{ iRow, iCol } ) )			fprintf( fid, '\t' );		else			fprintf( fid, '%s\t', num2str( casTableIn{ iRow, iCol } ) );		end	end	fprintf( fid, '\n' );endfclose( fid );retval = 1;function formatchanlabels( tAxisH )global gMF;for( iCh = 1:gMF.nChP )	axes( tAxisH( iCh ) );	tXL = xlim;	tLabX = 0.95 * ( tXL(2) - tXL(1) ) + tXL(1);	tYL = ylim;	tLabY = 0.90 * ( tYL(2) - tYL(1) ) + tYL(1);	tLH = findobj( get( gca, 'Children' ), 'flat', 'Tag', 'ChanLabel' ); % try to get a handle to existing channel label	if( isempty( tLH ) ) % if it doesn't already exist, make one		text( tLabX, tLabY, gMF.casChan{ ChanDI( iCh ) }, 'Tag', 'ChanLabel' );	else % otherwise...		if ~strcmp( get( tLH, 'string' ), gMF.casChan{ ChanDI( iCh ) } ) % new label name needed			set( tLH, 'string', gMF.casChan{ ChanDI( iCh ) } )		end		set( tLH, 'position', [ tLabX tLabY ] ); % reset its position	endendfunction formatspecaxes()global gMF;formataxes( gMF.SpecPlot );for( iCh = 1:gMF.nChP ) 	set( gMF.SpecPlot( iCh ), 'XLim', get( gMF.SpecPlot( iCh ), 'XLim' ) - [ 1 0 ] );endfunction formatwaveaxes()global gMF;formataxes( gMF.WavePlot );function formataxes( tAxisH )global gMF;for( iCh = 1:gMF.nChP )	axes( tAxisH( iCh ) );	axis tight;	tYLim( iCh, : ) = get( tAxisH( iCh ), 'YLim' );endtYMin = min( min( tYLim ) );tYMax = max( max( tYLim ) );for( iCh = 1:gMF.nChP )	axes( tAxisH( iCh ) );	set( gca,	'YLim', [ tYMin tYMax ], ...					'LineWidth', 1, ...					'FontWeight', 'bold' );endformatchanlabels( tAxisH );setmenu( 'on', 'ResetWaveYLim' );function rTF = isanybetsubj()% returns true if this has any possible between-subject comparisons, i.e.,% if all subject names are the same and in the same order in all conditions% be careful... will not detect if other part of subject folder name is differentglobal gMF;rTF = 0; % assume false until proven truetNCnd = length( gMF.casCond );for iCond1 = 1:( tNCnd-1 )	tNS1 = length( gMF.casSess{ iCond1 } );	for iCond2 = ( iCond1+1 ):tNCnd		tNS2 = length( gMF.casSess{ iCond2 } );		if tNS1 ~= tNS2			rTF = 1;			return;		end		for iS = 1:tNS1			if( ~strcmp( subjname( iCond1, iS ),  subjname( iCond2, iS ) ) )				rTF = 1;				return;			end		end	endendfunction rTF = iswinsubjcond()% returns true if current comparison is a within-subject, i.e.,% if all subject names are the same and in the same order% be careful... will not detect if other part of subject folder name is differentglobal gMF;rTF = 1; % assume true until proven falsetNS1 = length( gMF.casSess{ gMF.iCond1 } );tNS2 = length( gMF.casSess{ gMF.iCond2 } );if tNS1 ~= tNS2	rTF = 0;	return;endfor iS = 1:tNS1	if( ~strcmp( subjname( gMF.iCond1, iS ),  subjname( gMF.iCond2, iS ) ) )		rTF = 0;		return;	endendfunction montage( aStr )global gMF;for iCond = 1:length( gMF.casCond )	switch aStr	case 'ChanNumbers'		gMF.casChan = channames( [ 1:gMF.nChD ] );	case 'AverageReference' % use this until re-referenced mat file exports are available		tNCh = size( gMF.Data{iCond}.R, 2 );		gMF.Data{iCond}.R = gMF.Data{iCond}.R - repmat( mean( gMF.Data{iCond}.R, 2 ), 1, tNCh );		gMF.Data{iCond}.Cos = gMF.Data{iCond}.Cos - repmat( mean( gMF.Data{iCond}.Cos, 2 ), 1, tNCh );		gMF.Data{iCond}.Sin = gMF.Data{iCond}.Sin - repmat( mean( gMF.Data{iCond}.Sin, 2 ), 1, tNCh );		gMF.Data{iCond}.A = abs( gMF.Data{iCond}.Cos + gMF.Data{iCond}.Sin * i );		gMF.casChan = channames( [ 1:gMF.nChD ] );	case 'PO5OzPO6' % for CH Kanizsa		gMF.Data{iCond}.R = cat( 2, mean( gMF.Data{iCond}.R( :, 66:67, : ), 2 ), ...									mean( gMF.Data{iCond}.R( :, [ 72 73 77 ], : ), 2 ), ...									mean( gMF.Data{iCond}.R( :, [ 78 85 ], : ), 2 ) );		gMF.Data{iCond}.Cos = cat( 2, mean( gMF.Data{iCond}.Cos( :, 66:67, : ), 2 ), ...									mean( gMF.Data{iCond}.Cos( :, [ 72 73 77 ], : ), 2 ), ...									mean( gMF.Data{iCond}.Cos( :, [ 78 85 ], : ), 2 ) );		gMF.Data{iCond}.Sin = cat( 2, mean( gMF.Data{iCond}.Sin( :, 66:67, : ), 2 ), ...									mean( gMF.Data{iCond}.Sin( :, [ 72 73 77 ], : ), 2 ), ...									mean( gMF.Data{iCond}.Sin( :, [ 78 85 ], : ), 2 ) );		gMF.Data{iCond}.A = abs( gMF.Data{iCond}.Cos + gMF.Data{iCond}.Sin * i );		gMF.nChD = 3;		gMF.casChan = { 'PO5'; 'Oz'; 'PO6' };	case 'EyeChan' % for CH Kanizsa		gMF.Data{iCond}.R = cat( 2, mean( gMF.Data{iCond}.R( :, [ 33 128 ], : ), 2 ) - mean( gMF.Data{iCond}.R( :, [ 1 125 ], : ), 2 ), ...									mean( gMF.Data{iCond}.R( :, [ 8 26 ], : ), 2 ) - mean( gMF.Data{iCond}.R( :, [ 126 127 ], : ), 2 ) );		gMF.Data{iCond}.Cos = cat( 2, mean( gMF.Data{iCond}.Cos( :, [ 33 128 ], : ), 2 ) - mean( gMF.Data{iCond}.Cos( :, [ 1 125 ], : ), 2 ), ...									mean( gMF.Data{iCond}.Cos( :, [ 8 26 ], : ), 2 ) - mean( gMF.Data{iCond}.Cos( :, [ 126 127 ], : ), 2 ) );		gMF.Data{iCond}.Sin = cat( 2, mean( gMF.Data{iCond}.Sin( :, [ 33 128 ], : ), 2 ) - mean( gMF.Data{iCond}.Sin( :, [ 1 125 ], : ), 2 ), ...									mean( gMF.Data{iCond}.Sin( :, [ 8 26 ], : ), 2 ) - mean( gMF.Data{iCond}.Sin( :, [ 126 127 ], : ), 2 ) );		gMF.Data{iCond}.A = abs( gMF.Data{iCond}.Cos + gMF.Data{iCond}.Sin * i );		gMF.nChD = 2;		gMF.casChan = { 'Horizontal'; 'Vertical' };	case 'OccipitalTransept'% 		tChIs = [ 59 60 66 67 72 73 77 78 85 86 92 ]; % GSN		tChIs = [ 59 65 66 70 71 75 76 83 84 90 91 ]; % HCN		gMF.Data{iCond}.R = gMF.Data{iCond}.R( :, tChIs , : );		gMF.Data{iCond}.Cos = gMF.Data{iCond}.Cos( :, tChIs , : );		gMF.Data{iCond}.Sin = gMF.Data{iCond}.Sin( :, tChIs , : );		gMF.Data{iCond}.A = gMF.Data{iCond}.A( :, tChIs , : );		gMF.nChD = length( tChIs );		gMF.casChan = channames( tChIs );	otherwise		warndlg( 'Attempt to calculate undefined montage' );	endendfunction normalizedataglobal gMF;tNCnd = length( gMF.casCond );if( ~isanybetsubj )	[ tNR, tNC, tNP ] = size( gMF.Data{ 1 }.R );	tR = zeros( tNR * tNCnd, tNC, tNP );	for iCond = 1:tNCnd		tR( ( 1:tNR ) + ( iCond - 1 ) * tNR, :, : ) = gMF.Data{ iCond }.R;	end	tR = reshape( tR, [ tNR * tNCnd * tNC, tNP ] );	tR = ( tR - repmat( mean( tR ), size( tR, 1 ), 1 ) ) ./ repmat( std( tR ), size( tR, 1 ), 1 );	tR = reshape( tR, [ tNR * tNCnd, tNC, tNP ] );	for iCond = 1:tNCnd		gMF.Data{ iCond }.N = tR( ( 1:tNR ) + ( iCond - 1 ) * tNR, :, : );	endelse	for iCond = 1:tNCnd		gMF.Data{ iCond }.N = gMF.Data{ iCond }.R;	endendfunction rB = num2bits( aV, aN )tV = aV(:); % Make sure v is a row vector.tNV = length( tV ); % number of numbers to convertrB = zeros( tNV, aN );tP = aN - 1;rB( :, 1 ) = mod( tV, ( 2 ^ aN ) );for iP = 1:( aN - 1 )	rB( :, iP+1 ) = mod( rB( :, iP ), ( 2 ^ tP ) );	rB( :, iP ) = floor( rB( :, iP ) / ( 2 ^ tP ) );	tP = tP - 1;endrB( :, end ) = floor( rB( :, end ) / ( 2 ^ tP ) );function rC = num2comb( aV, aNG, aNS )% Parse the vector aV into a matrix of bitfields, rC, representing unique combinations% of a group of aNG subjects taken from aNS subjects.  Each element of aV must be in the% range [ 1:tNCT ] where tNCT is the total number of possible combinations.% Reasonably fast -- does about 1000 values per second.tNV = length( aV );rC = zeros( tNV, aNS );for iV = 1:tNV	rC( iV, : ) = num2comb_val( aV( iV ), aNG, aNS ); % call the helper functionendfunction rC = num2comb_val( aV, aNG, aNS )% helper function for num2comb to do the heavy liftingtNCR = prod( (aNS - aNG + 1):aNS ) / prod( 1:aNG ); % number of combinations remainingtNGR = aNG; % number of group slots remaining to be assignedtNSR = aNS; % number of subjects remaining% Among the remaining combinations, how many have the first subject true?% this is simply the probability of any given subject being true given the% remaining numbers of group slots and subjects, times the total number of% remaining combinations.  If a subject is "true", s/he is in the group.tNCT = tNGR / tNSR * tNCR;tNCF = tNCR - tNCT; % how many are false?rC = zeros( 1, aNS ); % the bitfield of the result combination, default zerotV = aV; % copy of argument to parsefor iS = 1:aNS % an index indicating the current subject	% is the current value above the range of combinations where the current subject is true?	if( tV > tNCT ) % the current subject is false, implicity keep the default zero bit		% number of combinations remaining is now those where the current subject is false		tNCR = tNCF;		% find remainder of tV after skipping over combinations where current subject is true		tV = tV - tNCT;	else		rC( iS ) = 1; % the current subject is true, set the corresponding bit		% number of combinations remaining is now those where the current subject is true		tNCR = tNCT; 		tNGR = tNGR - 1; % number of group slots remaining to be assigned		if( tNGR == 0 )			break;		end	end	tNSR = tNSR - 1; % number of subjects remaining	% Among the remaining combinations, how many have the next subject true?	tNCT = tNGR / tNSR * tNCR;	tNCF = tNCR - tNCT; % how many are false?endfunction PlotSig( asDataType, aOmnibus, aTRuns, asDotsTop )% arguments switch between:% 							"R" = unnormalized or "N" = normalized data%							"O" = omnibus or "C" = chan-by-chan test%							"R" = T-runs or "V" = T-values%							"T" = dots at top or "W" = dots on waveform (not implemented in GUI yet)global gMF; % get access to saved datatNWaveforms = length( findobj( get( gMF.WavePlot( 1 ), 'Children' ), 'flat', 'type', 'line' ) );if( tNWaveforms > 2 )	warndlg( 'Too many waveforms! try clearing and replotting', 'ERROR' );else	tSigIndx = getfield( gMF, [ 'SigIndx' asDataType aOmnibus aTRuns ] );	tfIsEmpty = isempty( tSigIndx{gMF.iCond1, gMF.iCond2} ); % particular combination of conditions have never been tested	tAns = 'Recalculate'; % default behavior is to (re)calculate significant differences	if ~tfIsEmpty % significant differences have been previously calculated and saved		tAns = questdlg( 'Sig indices exist...', 'Plot Sig', 'Reuse', 'Recalculate', 'Reuse' ); % allow user to choose to reuse old values	end	if strcmp( tAns, 'Recalculate' )		SetComparisonData( asDataType, aTRuns );		ReCalcRefDist( asDataType, aTRuns );		gMF = rmfield( gMF, 'CmpData' ); % destroy field created by SetComparisonData		tSigIndx = getfield( gMF, [ 'SigIndx' asDataType aOmnibus aTRuns ] );	end	tT = gMF.Data{gMF.iCond1}.T; % time axis	tMD1 = mean( getfield( gMF.Data{ gMF.iCond1 }, asDataType ), 3 ); % tNSamples x nCh	tMD2 = mean( getfield( gMF.Data{ gMF.iCond2 }, asDataType ) ,3 );	for( iCh = 1:gMF.nChP )		tSI = tSigIndx{gMF.iCond1,gMF.iCond2}( :, ChanDI( iCh ) ); % significant indices for this channel		tX = tT( tSI ); % time coordinates of significant data%	The following code overlays signficant points on top of waveform(s)... 		if( tNWaveforms == 2 ) 			tY = [ tMD1( tSI, iCh ) tMD2( tSI, iCh ) ]; % significant potentials for each waveform 		elseif( tNWaveforms == 1 ) % difference data 			tY = [ tMD1( tSI, iCh ) - tMD2( tSI, iCh ) ]; % significant difference potentials			 		end				subplot( gMF.WavePlot( iCh ) );%		tY = 0.95 * max( ylim ) * ones( size( tX ) ); % this plots significant points at top of pan		plot( tX, tY, 'k.', 'MarkerSize', 18 );	endendfunction PlotSpecScalar( aCond )global gMF;clearspecaxes;for( iCh = 1:gMF.nChP )	subplot( gMF.SpecPlot( iCh ) );	stem( gMF.Data{gMF.iCond1}.F, mean( gMF.Data{gMF.iCond1}.A(:,ChanDI( iCh ),:), 3 ), 'b.-' );	if( gMF.iCond2 > 0 )		stem( gMF.Data{gMF.iCond2}.F, -mean( gMF.Data{gMF.iCond2}.A(:,ChanDI( iCh ),:), 3 ), 'r.-' );	endendformatspecaxes;function PlotSpecVector( aCond )global gMF;clearspecaxes;for( iCh = 1:gMF.nChP )	subplot( gMF.SpecPlot( iCh ) );	tMeanCos = mean( gMF.Data{gMF.iCond1}.Cos(:,ChanDI( iCh ),:), 3 );	tMeanSin = mean( gMF.Data{gMF.iCond1}.Sin(:,ChanDI( iCh ),:), 3 );	stem( gMF.Data{gMF.iCond1}.F, abs( tMeanCos + tMeanSin*i ), 'b.-' );	if( gMF.iCond2 > 0 )		tMeanCos = mean( gMF.Data{gMF.iCond2}.Cos(:,ChanDI( iCh ),:), 3 );		tMeanSin = mean( gMF.Data{gMF.iCond2}.Sin(:,ChanDI( iCh ),:), 3 );		stem( gMF.Data{gMF.iCond2}.F, -abs( tMeanCos + tMeanSin*i ), 'r.-' );	endendformatspecaxes;function PlotTVals( asDataType )global gMF;ClearWaveAxes;tTScoreP = getfield( gMF, [ 'TScoreP' asDataType ] );tfIsEmpty = isempty( tTScoreP{ gMF.iCond1, gMF.iCond2 } ); % particular combination of conditions have never been testedtAns = 'Recalculate'; % default behavior is to (re)calculate significant differencesif ~tfIsEmpty % significant differences have been previously calculated and saved	tAns = questdlg( 'T-Scores exist...', 'Plot T-Scores', 'Reuse', 'Recalculate', 'Reuse' ); % allow user to choose to reuse old valuesendif strcmp( tAns, 'Recalculate' )	tR1 = getfield( gMF.Data{gMF.iCond1}, asDataType ); % asDataType toggles between .R (unnormalized) and .N (normalized)	tR2 = getfield( gMF.Data{gMF.iCond2}, asDataType );	if( iswinsubjcond | ( gMF.iCond1 == gMF.iCond2 ) )		if( gMF.iCond1 == gMF.iCond2 )		 	tPV = tcdf( -abs( TScore( tR1 ) ), size( tR1, 3 ) - 1 );		else		 	tPV = tcdf( -abs( TScore( tR2 - tR1 ) ), size( tR1, 3 ) - 1 );		end	else		tPV = tcdf( -abs( TScore( tR1, tR2 ) ), size( tR1, 3 ) + size( tR2, 3 ) - 2 );	end	tTScoreP{gMF.iCond1, gMF.iCond2} = tPV;	gMF = setfield( gMF, [ 'TScoreP' asDataType ], tTScoreP );else	tPV = tTScoreP{gMF.iCond1, gMF.iCond2};endtGrayColMap = gray( 200 );tGrayColMap = tGrayColMap( end:-1:(end/2), : );tGrayColMap( 1, : ) = [ 1 1 0 ];tHotColMap = jmaColors('pval');tHotColMap(end,:) = [1 1 1];for( iCh = 1:gMF.nChP )	subplot( gMF.WavePlot( iCh ) );	tPVCh = tPV( :, ChanDI( iCh ) );	image( xlim, ylim, repmat( 2*tPVCh', 20, 1 ), 'CDataMapping', 'scaled' );%	colormap( tGrayColMap );	colormap( tHotColMap );       cMapMax = .05+2*.05/(size(tHotColMap,1));    set( gca, 'CLim', [ 0 cMapMax ] ); % set range for color scaleendformatwaveaxes;function PlotFDRTVals( asDataType )global gMF;tTScoreP = getfield( gMF, [ 'TScoreP' asDataType ] );tfIsEmpty = isempty( tTScoreP{ gMF.iCond1, gMF.iCond2 } ); % particular combination of conditions have never been testedtAns = 'Recalculate'; % default behavior is to (re)calculate significant differences% if ~tfIsEmpty % significant differences have been previously calculated and saved% 	tAns = questdlg( 'T-Scores exist...', 'Plot T-Scores', 'Reuse', 'Recalculate', 'Reuse' ); % allow user to choose to reuse old values% endif strcmp( tAns, 'Recalculate' )	tR1 = getfield( gMF.Data{gMF.iCond1}, asDataType ); % asDataType toggles between .R (unnormalized) and .N (normalized)	tR2 = getfield( gMF.Data{gMF.iCond2}, asDataType );	if( iswinsubjcond | ( gMF.iCond1 == gMF.iCond2 ) )		if( gMF.iCond1 == gMF.iCond2 )		 	tPV = tcdf( -abs( TScore( tR1 ) ), size( tR1, 3 ) - 1 );		else		 	tPV = tcdf( -abs( TScore( tR2 - tR1 ) ), size( tR1, 3 ) - 1 );		end	else		tPV = tcdf( -abs( TScore( tR1, tR2 ) ), size( tR1, 3 ) + size( tR2, 3 ) - 2 );        disp('Running between subject t-test')	end	tTScoreP{gMF.iCond1, gMF.iCond2} = tPV;	gMF = setfield( gMF, [ 'TScoreP' asDataType ], tTScoreP );else	tPV = tTScoreP{gMF.iCond1, gMF.iCond2};endnF = size(gMF.Data{gMF.iCond1}.A,1);nHarm = length( unique([2:gMF.Data{gMF.iCond1}.i1F2:nF 2:gMF.Data{gMF.iCond1}.i1F1:nF]));sortPV = sort(tPV(:));% tPV = % tSigIndx%nTests = 2*nHarm;nTests = length(tPV(:));[p_fdr] = fdr(tPV(:),.05)fdrList=.05*(linspace(1,nTests,length(tPV(:)))/(nTests));[idx] = find(fdrList'>sortPV(:));if ~isempty(idx)fdrThresh = sortPV(idx(end));else    fdrThresh = NaN;enddisplay(['Correcting for ' num2str(nTests) ' comparisons, FDR threshold: ' num2str(fdrThresh)]);lf = gcf;figure(42)clfloglog(sortPV(:))hold on;loglog(fdrList,'r');legend('Ordered P values','FDR threshold')title(['Correcting for ' num2str(nTests) ' comparisons, FDR threshold: ' num2str(fdrThresh)]);figure(lf)%%%%%%%%%%%%%tNWaveforms = length( findobj( get( gMF.WavePlot( 1 ), 'Children' ), 'flat', 'type', 'line' ) );% if( tNWaveforms > 2 )% 	warndlg( 'Too many waveforms! try clearing and replotting', 'ERROR' );% else% 	tSigIndx = getfield( gMF, [ 'SigIndx' asDataType aOmnibus aTRuns ] );	tT = gMF.Data{gMF.iCond1}.T; % time axis	tMD1 = mean( getfield( gMF.Data{ gMF.iCond1 }, asDataType ), 3 ); % tNSamples x nCh	tMD2 = mean( getfield( gMF.Data{ gMF.iCond2 }, asDataType ) ,3 );	for( iCh = 1:gMF.nChP )	%	tSI = tSigIndx{gMF.iCond1,gMF.iCond2}( :, ChanDI( iCh ) ); % significant indices for this channel        tSI = tPV(:,iCh)<fdrThresh;		tX = tT( tSI ); % time coordinates of significant data%	The following code overlays signficant points on top of waveform(s)... 		if( tNWaveforms >= 2 ) 			tY = [ tMD1( tSI, iCh ) tMD2( tSI, iCh ) ]; % significant potentials for each waveform 		elseif( tNWaveforms == 1 ) % difference data 			tY = [ tMD1( tSI, iCh ) - tMD2( tSI, iCh ) ]; % significant difference potentials			 		end				subplot( gMF.WavePlot( iCh ) );%		tY = 0.95 * max( ylim ) * ones( size( tX ) ); % this plots significant points at top of pan		plot( tX, tY, 'o', 'MarkerSize', 8,'linewidth',2 ,'color',[0 .5 0]);	end%end %if( tNWave% % % tGrayColMap = gray( 200 );% tGrayColMap = tGrayColMap( end:-1:(end/2), : );% tGrayColMap( 1, : ) = [ 1 1 0 ];% for( iCh = 1:gMF.nChP )% 	subplot( gMF.WavePlot( iCh ) );% 	tPVCh = tPV( :, ChanDI( iCh ) );% 	image( xlim, ylim, repmat( tPVCh', 20, 1 ), 'CDataMapping', 'scaled' );% 	colormap( tGrayColMap );% 	set( gca, 'CLim', [ 0.025 0.5 ] ); % set range for color scale% end% formatwaveaxes;function PlotWaveform( asDataType, asPlotType ) % MO SO MD SDglobal gMF;for( iCh = 1:gMF.nChP )	tX = gMF.Data{gMF.iCond1}.T; % time axis	tWF = getfield( gMF.Data{gMF.iCond1}, asDataType ); % waveform data, either R or N	subplot( gMF.WavePlot( iCh ) );	if( asPlotType( 1 ) == 'M' ) % mean across subjects		tY1 = nanmean( tWF(:,ChanDI( iCh ),:), 3 );	elseif( asPlotType( 1 ) == 'S' ) % individual subjects		tY1 = squeeze( tWF(:,ChanDI( iCh ),:) );	end	if( asPlotType( 2 ) == 'O' ) % original data  		tH = plot( tX, tY1, 'b-', 'LineWidth', 1 ); % b/w plotting% 		tH = plot( tX, tY1, 'b-', 'LineWidth', 2 ); % color plotting		for iH = 1:length( tH )			set( tH( iH ), 'Tag', subjname( gMF.iCond1, iH ) );		end	end	if( gMF.iCond2 > 0 )		tWF = getfield( gMF.Data{gMF.iCond2}, asDataType );		if( asPlotType( 1 ) == 'M' ) % mean across subjects			tY2 = nanmean( tWF(:,ChanDI( iCh ),:), 3 );		elseif( asPlotType( 1 ) == 'S' ) % individual subjects			tY2 = squeeze( tWF(:,ChanDI( iCh ),:) );		end		if( asPlotType( 2 ) == 'O' ) % original data 	 		tH = plot( tX, tY2, 'r-', 'LineWidth', 2 ); % b/w plotting%	 		tH = plot( tX, tY2, 'r-', 'LineWidth', 2 ); % color plotting			for iH = 1:length( tH )				set( tH( iH ), 'Tag', subjname( gMF.iCond2, iH ) );				% this allows us to hilight a particular subject thus...				% set(findobj( gMF.WavePlot, 'tag', 'Petrov' ),'color',[ 1 0 0 ],'linewidth',2 )			end		elseif( asPlotType( 2 ) == 'D' ) % difference data	 		tH = plot( tX, tY1 - tY2, 'g-', 'LineWidth', 2 );			for iH = 1:length( tH )				set( tH( iH ), 'Tag', subjname( gMF.iCond2, iH ) );			end		end	endendformatwaveaxes;if( asPlotType( 1 ) == 'M' & gMF.iCond2 > 0 )	if( asDataType == 'R' )		setmenu( 'on','PlotWaveSig' );	elseif( asDataType == 'N' )		setmenu( 'on','PlotNormSig' );	endend% function PlotTopoMap()% global gMF% tiT = gettimeindexfromplot();% % function tiT = gettimeindexfromplot()% tiT =  300;function PlotPLS()global gMF;tPLSDataExists = isfield( gMF, 'MAxxPLS' ); % PLS data have been previously calculated and savedtAns = 'Recalculate'; % default behavior is to (re)calculate PLS dataif tPLSDataExists	tAns = questdlg( 'PLS data exist...', 'Plot PLS Data', 'Reuse', 'Recalculate', 'Reuse' ); % allow user to choose to reuse old valuesendif strcmp( tAns, 'Recalculate' )	[ tCondSS, isOK ] = listdlg( 'ListString', gMF.casCond, 'SelectionMode', 'multiple', 'Name', 'Choose Conditions' ); % Condition SubScript	if( isOK ~= 1 )		return;	else		[ tNSamp, tNChan, tNSubj ] = size( gMF.Data{ tCondSS( 1 ) }.R );		tNCond = length( gMF.casCond( tCondSS ) );		tR = gMF.Data( tCondSS );		tY = [];		for iCond = 1:tNCond			tY = [ tY reshape( gMF.Data{ tCondSS( iCond ) }.R, tNSamp * tNChan, tNSubj ) ];		end		tNLoops = str2num( char( inputdlg( {'Number of Loops'}, 'PLS Significance Tests', 1, {'100'} ) ) );		gMF.MAxxPLS = MAxxPLS( tY, tNCond, tNLoops );		gMF.MAxxPLS.ScalpSc = tY' * gMF.MAxxPLS.EPB; % scalp scores, tNCond * tNSubj x tNCond		gMF.MAxxPLS.CondSS = tCondSS;	endend% % uncomment this block of code to confine plot to occipital transept channels for HCN 128% tOccTrnsptCh = [ 59 60 66 67 71 72 76 77 84 85 92 ];% gMF.casChan = channames( tOccTrnsptCh );% gMF.nChP = length( tOccTrnsptCh );% set( findobj( 'Tag', 'ChanSlider' ), 'Enable', 'off', 'UserData', [ 1:gMF.nChP ] );% if( isfield( gMF.SpecPlot, 'axis' ) )% 	clearspecaxes;% 	ClearWaveAxes;% end% createaxes;[ tLVSS, isOK ] = listdlg( 'ListString', num2str( gMF.MAxxPLS.SVPVal ), 'SelectionMode', 'single', 'Name', 'Choose LV' ); % Latent Variable SubScript% Start with waveform plots of EP basis vectors for each channeltT = gMF.Data{ 1 }.T; % time axis% tSigRatio = str2num( char( inputdlg( {'Significance ratio'}, 'Bootstrap Std Error', 1, {'3'} ) ) );tSigRatio = norminv( 1 - 0.025 / gMF.nChD / tNSamp );for( iCh = 1:gMF.nChP ) 	tCh = ChanDI( iCh ); % For slider	subplot( gMF.WavePlot( iCh ) );	tSampSS = [ 1:tNSamp ] + ( ( tCh - 1 ) * tNSamp ); % sample subscripts	tScaledEP = gMF.MAxxPLS.EPB( tSampSS, tLVSS ) * gMF.MAxxPLS.SV( tLVSS, tLVSS );	plot( tT, tScaledEP, 'c-', 'LineWidth', 1 );	tScaledEPStErr = gMF.MAxxPLS.EPBStErr( tSampSS, tLVSS );	tSigSampSS = abs( tScaledEP ) > tSigRatio * tScaledEPStErr;	plot( tT( tSigSampSS ), tScaledEP( tSigSampSS ), 'c.', 'MarkerSize', 15 );	if( tCh == 4 )% 		assignin( 'base', 'tPLSLV', [ tT tScaledEP tSigSampSS ] );	endendformatwaveaxes;% Get a screensize vector to use for creating supplementary windowstScreenSize = get( 0, 'ScreenSize' );tScreenSize( 1:2 ) = tScreenSize( 3:4 );% Now do synoptic plot of same EP basis vectorstScaledEP = gMF.MAxxPLS.EPB( :, tLVSS ) * gMF.MAxxPLS.SV( tLVSS, tLVSS );tScaledEPStErr = gMF.MAxxPLS.EPBStErr( :, tLVSS );tSigSampSS = abs( tScaledEP ) > tSigRatio * tScaledEPStErr;tImage = reshape( tScaledEP, tNSamp, gMF.nChD );tH = synopticimage( tImage', 'RGB' ); % the first pass sets up the CLim for the image;% set( gcf, 'Position', tScreenSize .* [ 0.3828 0.0533 0.5751 0.8828 ] );set( gcf, 'units', 'normalized', 'Position', [ 0.3828 0.0533 0.5751 0.8828 ], 'Name', [ gMF.MatFN(1:findstr('.mat',gMF.MatFN)-1) ': LV' num2str(tLVSS) ] );tImage( tSigSampSS ) = 2 * max( max ( tImage ) ); % push significant entries up past CLim for synopticimageset( tH, 'cdata', tImage' ); % the new image tags the significant points with white;set( gca, 'xtick', linspace( 1, tNSamp, 11 ), 'xticklabel', num2str( round( linspace( 0, 10 * round( tT(end) / 10 ), 11 )' ) ) );figure( 'Name', 'Condition Load Factors', 'Position', tScreenSize .* [ 0.0166 0.5234 0.3398 0.4128 ] );bar( gMF.MAxxPLS.CondB( :, tLVSS ) );set( gca, 'XTickLabel', char( gMF.casCond( gMF.MAxxPLS.CondSS ) ) ); % for testing only; only plots first LVfigure( 'Name', 'Subject Scores', 'Position', tScreenSize .* [ 0.0166 0.0547 0.3398 0.4128 ] );tPlotSymbol = [ 'bo';'rx';'g+';'m*';'bs';'rd';'g^';'m<';'bp';'r>';'gh';'mv';'ro';'gx';'m+';'b*';'rs';'gd';'m^';'b<' ];tNCond = size( gMF.MAxxPLS.CondB, 1 );for iCond = 1:tNCond	tScalpScSS = [ 1:tNSubj ] + ( ( iCond - 1 ) * tNSubj ); % scalp score subscripts	tScalpSc = gMF.MAxxPLS.ScalpSc( tScalpScSS, tLVSS );	tCondBSc = gMF.MAxxPLS.CondB( iCond, tLVSS ) * ones( size( tScalpSc ) );	plot( tCondBSc, tScalpSc, tPlotSymbol( iCond, : ) );	hold on;endlegend( gMF.casCond{ gMF.MAxxPLS.CondSS }, 0 );hold off;function prepareaxes()% should called by CondSingle and CondDouble onlyglobal gMF;if( gMF.nChD >= 128 )	gMF.nChP = 8;  % we can only look at 8 channels at a time	set( findobj( 'Tag', 'ChanSlider' ), 'Enable', 'on' );else	gMF.nChP = gMF.nChD;endif( isfield( gMF.SpecPlot, 'axis' ) )	clearspecaxes;% 	ClearWaveAxes;else	createaxes;endfunction ProjOpenTxt()global gMF;if( ~isempty( gMF.MatFN ) )	Destructor;	Constructor;	global gMF;end[ gMF.FN, gMF.PN ]=uigetfile('*.txt','Open project text file'); % since conditions are only loaded as needed, we need record of source data locationgMF.MatFN = strrep( gMF.FN, '.mat', '' );gMF.MatPN = gMF.PN;set( findobj( 'Tag', 'ProjectText' ), 'String', gMF.FN );[ gMF.casCond, gMF.casSess ] = readprojectfile( [ gMF.PN gMF.FN ] );gMF.Data = cell( size( gMF.casCond ) );defaultsigindx;readallcondfiles;setmenu( 'off', 'PlotSpecVector', 'PlotSpecScalar', 'ResetSpecXLim', ...	'ClearWaveAxes', 'PlotWaveMean', 'PlotWaveMeanDiff', 'PlotWaveSubjects', 'PlotWaveSubjectsDiff', 'PlotWaveSig', 'PlotWaveTVals', 'ResetWaveYLim', ...	'ClearNormAxes', 'PlotNormMean', 'PlotNormMeanDiff', 'PlotNormSubjects', 'PlotNormSubjectsDiff', 'PlotNormSig', 'PlotNormTVals', ...	'PlotPLS', ...	'ExportRMSDiff', 'ExportPLSDataTableR', 'ExportPLSDataTableA' );setmenu( 'on', 'CondSingle', 'CondDouble', 'SplitData', 'AxxFilter' );if( isfield( gMF.SpecPlot, 'axis' ) )	clearspecaxes;	ClearWaveAxes;endfunction ProjOpenMat()global gMF;if( ~isempty( gMF.MatFN ) )	Destructor;	Constructor;	global gMF;end[ tFN, tPN ]=uigetfile('*.mat','Open project mat file');load( [ tPN tFN ], 'gMF' );gMF.MatFN = tFN;gMF.MatPN = tPN;set( findobj( 'Tag', 'ProjectText' ), 'String', gMF.MatFN );setmenu( 'off', 'PlotSpecVector', 'PlotSpecScalar', 'ResetSpecXLim', ...	'ClearWaveAxes', 'PlotWaveMean', 'PlotWaveMeanDiff', 'PlotWaveSubjects', 'PlotWaveSubjectsDiff', 'PlotWaveSig', 'PlotWaveTVals', 'ResetWaveYLim', ...	'ClearNormAxes', 'PlotNormMean', 'PlotNormMeanDiff', 'PlotNormSubjects', 'PlotNormSubjectsDiff', 'PlotNormSig', 'PlotNormTVals', ...	'PlotPLS', ...	'ExportRMSDiff', 'ExportPLSDataTableR', 'ExportPLSDataTableA' );setmenu( 'on', 'CondSingle', 'CondDouble', 'SplitData', 'AxxFilter' );if ~any( [ isfield( gMF, 'SigIndx' ) isfield( gMF, 'SigIndxN' ) isfield( gMF, 'SigIndxRCV' ) ] )	defaultsigindx;endif any( [ isfield( gMF, 'SigIndx' ) isfield( gMF, 'SigIndxN' ) ] )	defaultsigindx;	if isfield( gMF, 'SigIndx' ) % for backward compatibility with mat files created before this field was added		gMF.SigIndxRCV = gMF.SigIndx;		gMF = rmfield( gMF, 'SigIndx' );	end	if isfield( gMF, 'SigIndxN' ) % for backward compatibility with mat files created before this field was added		gMF.SigIndxNCV = gMF.SigIndxN;		gMF = rmfield( gMF, 'SigIndxN' );	endendif isfield( gMF, 'nCh' ) % for backward compatibility with mat files created before this field was changed	gMF.nChP = gMF.nCh( 1 );	gMF.nChD = gMF.nChP;	gMF = rmfield( gMF, 'nCh' );	gMF.casChan = channames( [ 1:gMF.nChD ] );endfunction readallcondfiles()% this function reads Axx....mat files% substitute this for calls to readcondfiles% be sure to use appropriate code in readprojectfileglobal gMF;tNCond = length( gMF.casCond );for iCond = 1:tNCond	tNSess = length( gMF.casSess{ iCond } );	tH = waitbar( 0, [ 'Loading ' gMF.casCond{ iCond } '...' ] );	for iSess = 1:tNSess		tAxx = load( [ gMF.PN gMF.casSess{ iCond }{ iSess } ] );		gMF.Data{iCond}.R( :, :, iSess ) = tAxx.Wave;		gMF.Data{iCond}.Cos( :, :, iSess ) = tAxx.Cos;		gMF.Data{iCond}.Sin( :, :, iSess ) = tAxx.Sin;		gMF.Data{iCond}.A( :, :, iSess ) = tAxx.Amp;		waitbar( iSess / tNSess );	end	gMF.Data{iCond}.T = tAxx.dTms * [ 0:( tAxx.nT - 1 ) ]';	gMF.Data{iCond}.F = tAxx.dFHz * [ 0:( tAxx.nFr - 1 ) ]';	if isfield( tAxx, 'i1F1' )		gMF.Data{iCond}.i1F1 = tAxx.i1F1;		gMF.Data{iCond}.i1F2 = tAxx.i1F2;	end	close( tH );endgMF.nChD = size( gMF.Data{iCond}.R, 2 );if( gMF.nChD >= 128 ) % number of channels is GSN	montage( 'AverageReference' );%  	montage( 'OccipitalTransept' ); % for CH Kanizsa%  	montage( 'PO5OzPO6' ); % for CH Kanizsaelse	montage( 'ChanNumbers' );endif( 1 ) % disables memory-intensive normalization	warndlg( 'Normalization disabled' )	for iCond = 1:length( gMF.casCond )		gMF.Data{ iCond }.N = gMF.Data{ iCond }.R;	endelse	normalizedata;end	function [ casCond, casSess ] = readprojectfile( asPFN )global gMF;casD = tdt2cas( asPFN );iCond = 0;iSess = 1;for iR = 1:size( casD, 1 )	if( isempty( casD{ iR, 2 } ) )		iCond = iCond + 1;		casCond{ iCond } = casD{ iR, 1 };		iSess = 1;	else		sSsnFolderName = strcat( casD{ iR, 1 }, '_', casD{ iR, 2 }(1:end-2) );		stDir = dir( [ gMF.PN sSsnFolderName ] );		if( size( stDir, 1 ) > 0 )			[ casDirNames{ 1:size( stDir, 1 ) } ] = deal( stDir.name );		else			disp( [ 'Can not find/open ' sSsnFolderName ] );			Destructor;		end		sExportFolderName = 'Exp_MATL_PD1010_5_Cz';		sCN = [ '00' casD{ iR, 3 } ];		sCN = sCN( end-2:end );		casSess{ iCond }{ iSess } = strcat( sSsnFolderName, ':', sExportFolderName, ':Axx_c', sCN, '.mat' );% 		if isempty( dir( [ gMF.PN casSess{ iCond }{ iSess } ] ) )% 			casSess{ iCond }{ iSess } = strrep( casSess{ iCond }{ iSess }, 'Export_mtg1.mat', 'Export_mtg0.mat' );			if isempty( dir( [ gMF.PN casSess{ iCond }{ iSess } ] ) )				error( [ 'Condition matfile does not exist: ' casSess{ iCond }{ iSess } ] );			end% 		end		iSess = iSess + 1;	endendfunction tRV = readspecfile( asPFN )%Name	iChan	iFreq	Freq Hz	Cos	Sin	Amp	PVal% casD = tdt2cas( strrep( asPFN, 'XXXX', 'Spec' ) );% for i = 2:size( casD, 1 )% 	tRV( i-1, : ) = str2num( char( casD( i, 4:end ) ) )';% end% for loop replaces following which crashed on char( ... )% perhaps it's a little less memory intensive% tRV = reshape( str2num( char( casD( 2:end, 4:end ) ) ), size( casD )-[ 1 3 ] );tFID = fopen( strrep( asPFN, 'XXXX', 'Spec' ), 'r' );tsX = fgetl( tFID ); % skip over headings...tsX = fgetl( tFID );trTabs = findstr( tsX, 9 );tSkip = trTabs( 1 );% get the last row of the filetDist = -100;fseek( tFID, tDist, 'eof' );tsX = fscanf( tFID, '%c', [ inf ] );trNewLines = findstr( tsX, 13 );while( length( trNewLines ) < 2 )	tDist = tDist - 100;	fseek( tFID, tDist, 'eof' );	tsX = fscanf( tFID, '%c', [ inf ] );	trNewLines = findstr( tsX, 13 );endif( trNewLines( end ) == -tDist )	fseek( tFID, tDist + trNewLines( end - 1 ), 'eof' );else	fseek( tFID, tDist + trNewLines( end ), 'eof' );end% skip the LastName field...fseek( tFID, tSkip, 'cof' );% get the numeric datatX = fscanf( tFID, '%f', [ inf ] );% calculate dimensions of numeric part of tabletNCols = length( tX );tNRows = tX( 1 ) * tX( 2 );tRV = zeros( tNRows, tNCols - 2 );frewind( tFID );tsX = fgetl( tFID ); % skip over headings...for iR = 1:tNRows	fseek( tFID, tSkip, 'cof' );	tR = fscanf( tFID, '%f', [ tNCols, 1 ] );	tRV( iR, : ) = tR( 3:end )';endfclose( tFID );function tRV = readwavefile( asPFN )% casD = tdt2cas( strrep( asPFN, 'XXXX', 'Wave' ) );% for i = 2:size( casD, 1 )% 	tRV( i-1, : ) = str2num( char( casD( i, : ) ) )';% end% for loop replaces following which crashed on char( ... )% perhaps it's a little less memory intensive% tRV = reshape( str2num( char( casD( 2:end, : ) ) ), size(casD)-[ 1 0 ] );tFID = fopen( strrep( asPFN, 'XXXX', 'Wave' ), 'r' );tDist = -100;fseek( tFID, tDist, 'eof' );tsX = fscanf( tFID, '%c', [ inf ] );trNewLines = findstr( tsX, 13 );while( length( trNewLines ) < 2 )	tDist = tDist - 100;	fseek( tFID, tDist, 'eof' );	tsX = fscanf( tFID, '%c', [ inf ] );	trNewLines = findstr( tsX, 13 );endif( trNewLines( end ) == -tDist )	fseek( tFID, tDist + trNewLines( end - 1 ), 'eof' );else	fseek( tFID, tDist + trNewLines( end ), 'eof' );endtX = fscanf( tFID, '%f', [ inf ] );tNCols = length( tX );tNRows = tX( 1 ) * tX( 2 );frewind( tFID );tX = fgetl( tFID );tX = fscanf( tFID, '%f', [ tNCols, tNRows ] );fclose( tFID );tRV = tX';function ResetSpecXLim()global gMF;tDefXLim = gMF.Data{gMF.iCond1}.F( end );tNewXLim = str2num( char( inputdlg( [ 'Change XLim to ( ' num2str( tDefXLim ) ' )' ] ) ) );for( iCh = 1:gMF.nChP )	axes( gMF.SpecPlot( iCh ) );	set( gca, 'XLim', [ -1 tNewXLim ] );	tLines = get( gca, 'Children' );	for( iLine = 1:length( tLines ) )			if( strcmp( get( tLines( iLine ), 'Type' ), 'line' ) )				set( tLines( iLine ), 'LineWidth', tDefXLim / tNewXLim );			end	endendformatchanlabels( gMF.SpecPlot );function ResetWaveYLim()global gMF;axes( gMF.WavePlot( 1 ) ); % make current axistDefLim = axis; % get current axis dimensions [ Xmin Xmax Ymin Ymax ]tAns = inputdlg( {'YMax','YMin'}, 'Change Wave YLim', [ 1 1 ]', { num2str( tDefLim( 4 ) ), num2str( tDefLim( 3 ) ) }' ); % prompt, title, [ 1 1 ]', defaulttNewLim = [ tDefLim( 1:2 ) str2num( tAns{ 2 } ) str2num( tAns{ 1 } ) ];for( iCh = 1:gMF.nChP )	axes( gMF.WavePlot( iCh ) );	axis( tNewLim );endformatchanlabels( gMF.WavePlot ); % this still leaves hanging labels from previous plot... needs a patchfunction rms = rmsdifference()% calculates rms for a given difference wave potential % by subject and by channel% will output a text-delimited datafileglobal gMF;rms = std( gMF.Data{gMF.iCond1}.R - gMF.Data{gMF.iCond2}.R, 0, 1 );rmstext = num2str( rms );function rRST = runsigtscore( tX1, varargin )% takes the NSamples x NChan x NSub matrix/-ices of real or permuted difference potentials, tX1/&tX2,% and creates a NSamples x NChan matrix, rRST, whose elements describe the length and location% of runs of consecutively significant T-scores.  For each run of significant T-scores from tX1,% the length of the run is entered at the location of the last significant element in the run.[tNSamples, tNChans, tNSubs1 ] = size( tX1 );if( nargin == 1 )	tT = abs( TScore( tX1 ) );	tTCrit = tinv( 0.975, tNSubs1 - 1 );else	tNSubs2 = size( varargin{ 1 }, 3 );	tT = abs( TScore( tX1, varargin{ 1 } ) );	tTCrit = tinv( 0.975, tNSubs1 + tNSubs2 - 2 );endtTSigI = tT > tTCrit;rRST = zeros( tNSamples, tNChans ); % matrix for runs of significant t-scoresfor iCh = 1:tNChans	tCRST = tTSigI( 1, iCh ); % counter for current run of significant t-scores	for iS = 2:tNSamples		if( tTSigI( iS, iCh ) < tTSigI( iS - 1, iCh ) )			rRST( iS - 1, iCh ) = tCRST;			tCRST = 0;		else			tCRST = tCRST + tTSigI( iS, iCh );		end	endendfunction rvfSaveOK = savegMF( aPN, aFN ) % rvfSaveOK == 0 indicates user cancelled or aborted a failed save attemptglobal gMF;tCurrWD = pwd;cd( aPN );% [ tFN, tPN ] = uiputfile( aFN, 'Save as .mat file...' );[ tFN, tPN ] = uiputfile( strrep( aFN, 'txt', 'mat' ), 'Save as .mat file...' );rvfSaveOK = tFN ~= 0; % user did not cancel save operationif( rvfSaveOK ) 	eval( 'save( [ tPN tFN ], ''gMF'' );', 'rvfSaveOK = 0;' );	if( rvfSaveOK == 0 ) % save operation failed		if( strcmp( questdlg( 'Save operation failed', 'ERROR!', 'Try Again', 'Abort', 'Try Again' ) ) )			rvfSaveOK = savegMF( aPN, aFN );		end	endendcd( tCurrWD );function rv = sgnpermat( aX, asReturnType )tX = aX( 1 );for i = 2:length( aX )	tX = [ tX; -tX ];	tX = [ tX aX( i ) * ones( size( tX, 1 ), 1 )  ];endswitch asReturnType,case 'half',	rv = tX;% tNPermutations x tNSubscase 'full',	rv = [ tX; -tX ];otherwise,	error( 'sgnpermat requires specification of half or full permutation' );	rv = [];endrv = reshape( rv, [ size(rv,1) , 1, size( rv, 2 ) ] ); % tNPermutations x 1 x tNSubsfunction selectcond( a2ndCond ) %The value passed into this function is 0 or 1global gMF;[ iCond, tOK ] = listdlg( 'ListString', gMF.casCond, 'SelectionMode', 'single' );if( a2ndCond )	set( findobj( 'Tag', '2ndCondText' ), 'String', gMF.casCond{ iCond } );	gMF.iCond2 = iCond;else	set( findobj( 'Tag', '1stCondText' ), 'String', gMF.casCond{ iCond } );	gMF.iCond1 = iCond;	set( findobj( 'Tag', '2ndCondText' ), 'String', '2nd Cond' );	gMF.iCond2 = 0;endfunction setmenu( asState, varargin )for i = 1:( nargin - 1 )	set( findobj('Tag', varargin{ i } ), 'Enable', asState );endfunction splitdata()global gMF;gMF.MatFN = [ gMF.MatFN( 1:( findstr( '.', gMF.MatFN) - 1 ) ) '_Split' gMF.MatFN( ( findstr( '.', gMF.MatFN) ):end ) ];gMF.casCond = cat( 2, gMF.casCond, gMF.casCond );gMF.casSess = cat( 2, gMF.casSess, gMF.casSess );gMF.Data = cat( 2, gMF.Data, gMF.Data );tN = length( gMF.Data{ 1 }.T );t1stRange = [ 1:( tN / 2 ) ]; % index into 1st half of data ranget2ndRange = [ ( tN / 2 + 1 ):tN ]; % 2nd halftNConds = length( gMF.casCond );for iCond = 1:(tNConds/2) % the first half of conditions...	gMF.casCond{ iCond } = [ gMF.casCond{ iCond } '_1st' ]; % label it	gMF.Data{ iCond }.T = gMF.Data{ iCond }.T( t1stRange, :, : ); % 1st half of time sequence...	gMF.Data{ iCond }.R = gMF.Data{ iCond }.R( t1stRange, :, : ); % response data	gMF.Data{ iCond }.N = gMF.Data{ iCond }.N( t1stRange, :, : ); % normalized response dataendfor iCond = (tNConds/2+1):tNConds	gMF.casCond{ iCond } = [ gMF.casCond{ iCond } '_2nd' ];	gMF.Data{ iCond }.T = gMF.Data{ iCond }.T( t1stRange, :, : ); % use same time sequence as 1st half of range	gMF.Data{ iCond }.R = gMF.Data{ iCond }.R( t2ndRange, :, : );	gMF.Data{ iCond }.N = gMF.Data{ iCond }.N( t2ndRange, :, : );enddefaultsigindx;setmenu( 'off', 'SplitData' );function rSN = subjname( aCond, aSubj )global gMF;tsSsn = gMF.casSess{ aCond }{ aSubj };ts_ = findstr( '_', tsSsn );if ~isempty( ts_ )	rSN = tsSsn( 1:( ts_ - 1 ) );else	rSN = tsSsn;endfunction tH = synopticimage( tImage, tCMapFlag )figure;tNC = 200; % number of colorsswitch tCMapFlag	case 'RGB',		tCMap = hsv( 1.5 * tNC );		tCMap = fliplr( tCMap( 1:tNC, : ) );	case 'Flow',		tCMap = zeros( 200, 3 );		tCMap( 134:end, 1 ) = linspace( .5, 1, 67 )';		tCMap( 1:67, 3 ) = linspace( 1, .5, 67 )';		tCMap( [ 1:67 ] + 67, : ) = 0.5 * ones( 67, 3 );	otherwise % 'gray',		tCMap = gray( tNC );endtH = image( tImage, 'CDataMapping', 'scaled' ); % by default, vertical invert; enable scaled color mapping% Extend the color range beyond the extrema of data range to create % head/floor-room for CMap entries that denote significancetMx = max( max( tImage ) );tMn = min( min( tImage ) );tMInc = ( tMx - tMn ) / tNC;set( gca, 'CLim', [  tMn - 2*tMInc tMx + 2*tMInc ] );% add the white entries to the extrema of the CMaptCMap = [ [ 0 0 0 ]; tCMap; [ 0 0 0 ] ];colormap( tCMap );% axis image;% axis off;function casRV = tdt2cas( asPFN )tPathSeps = findstr( asPFN, ':' );if( length( tPathSeps ) > 2 )	tsAbbrevPFN = asPFN( tPathSeps( end - 2 ):end );else	tsAbbrevPFN = asPFN;endtsAbbrevPFN = strrep( tsAbbrevPFN, '_', '\_' ); % without '\', underscore causes subscriptingstFileStats = dir( asPFN );tFileSize = stFileStats.bytes;tFID = fopen( asPFN, 'r' );if( tFID ~= -1 )	iR = 1;	tStr = fgetl( tFID );%  	tH = waitbar( ftell( tFID ) / tFileSize, [ 'Reading TDT file: ...' tsAbbrevPFN ] );%	The following will split text (ugly) between two lines in window%	tH = waitbar( ftell( tFID ) / tFileSize, { 'Reading TDT file: ...', tsAbbrevPFN } );	while( tStr ~= -1 )		iC = 1;		[a,b]=strtok(tStr,'	');		while( ~isempty(a) )			casRV{iR,iC} = a;			[a,b]=strtok(b,'	');			iC = iC + 1;		end		tStr = fgetl( tFID );		iR = iR + 1;% 		waitbar( ftell( tFID ) / tFileSize );	end% 	close( tH );	fclose(tFID);endfunction tH = topoplot( tChData, tDataType, tSigIndx, tLabels, tNetType, tChanMask, varargin )% tChData:		the 128-channel scalp potential/amplitude vector % tDataType:	'Time' | 'Freq';% tSigIndx:		significant channel indices; 128x1 logical index vector% tLabels:		'LabelsOn' | 'LabelsOff'; channel labels% tNetType:		'HCN' | 'GSN'% tChanMask:	a 128-channel logical subscript for masking out certain channels (passed on to topospline)% varargin:		tMx, tMn: optional manual extrema for z-scale% tXMx, tYMx:	coordinates of global maximum% v1 = v0 +	reorganized calling chain so plotting is separate from interpolation%			make topospline a separately accessible function%			eliminate daisy option%			pass figure handle back to caller[ tTopoMap, tChX, tChY ] = topospline( tChData, tDataType, tNetType, tChanMask );tH = topoimage( tTopoMap, tDataType, varargin{:} );% Optionally plot significant channels, optionally with labelshold on;plot( tChX( tSigIndx ), tChY( tSigIndx ), 'k.', 'markersize', 18, 'color', [ 0 0 0 ] );if strcmp( tLabels, 'LabelsOn' )	tChI = [ 1:128 ];	for iCh = tChI( tSigIndx );		text( tChX( iCh ), tChY( iCh ), num2str( iCh ), 'color', [ 1 1 1 ] );	endendfunction tH = topoimage( tImage, tDataType, varargin )figure;tNC = 200; % number of colorsswitch tDataType	case 'Freq',		tCMap = hot( tNC );	case 'Time',		tCMap = zeros( 200, 3 );		tCMap( 134:end, 1 ) = linspace( .5, 1, 67 )';		tCMap( 1:67, 3 ) = linspace( 1, .5, 67 )';		tCMap( [ 1:67 ] + 67, : ) = 0.5 * ones( 67, 3 );	case 'RGB',		tCMap = hsv( 1.5 * tNC );		tCMap = fliplr( tCMap( 1:tNC, : ) );	otherwise % 'gray',		tCMap = gray( tNC );endimage( tImage, 'CDataMapping', 'scaled' ); % by default, vertical invert; enable scaled color mapping% Extend the color range beyond the extrema of data range to create % head/floor-room for CMap entries that denote significanceif( nargin > 2 )	tMx = varargin{ 1 };	tMn = varargin{ 2 };else	tMx = max( max( tImage ) );	tMn = min( min( tImage ) );endtMInc = ( tMx - tMn ) / tNC;set( gca, 'CLim', [  tMn - 2*tMInc tMx + 2*tMInc ] );% add the white entries to the extrema of the CMaptCMap = [ [ 0 0 0 ]; tCMap; [ 1 1 1 ] ];colormap( tCMap );axis image;axis off;tH = gcf;function [ tTopoMap, tChX, tChY ] = topospline( tChData, tDataType, tNetType, tChanMask )% function [ tTopoMap, tChX, tChY ] = topospline( tChData, tDataType, tNetType, tChanMask )% Parameters:% 	tChData:	the 128-channel scalp potential/amplitude vector % 	tDataType:	'Time' | 'Freq';% 	tNetType:	'HCN' | 'GSN'%	tChanMask:	a 128-channel logical subscript for masking out certain channels% Return values:% 	tTopoMap:	The maxtrix of topomap data suitable for imaging% 	tChX, tChY:	coordinates of selected net type channel positions in tTopoMap's ref.frametChPos = ChPos( tNetType );tChX = tChPos( tChanMask, 1 );tChY = tChPos( tChanMask, 2 );tNCh = size( tChPos, 1 );tDF = 50; % density factortNGP = round( sqrt( tDF * tNCh * 4 / pi ) ); % number of grid points (per side)[ tX, tY ] = meshgrid( linspace( 0, 1.0, tNGP ) );tY = flipud( tY );tTopoMap = griddata( tChX, tChY, tChData( tChanMask ), tX, tY, 'cubic' );tChX = round( ( tNGP - 1 ) * tChPos( tChanMask, 1 ) ) + 1;tChY = round( ( tNGP - 1 ) * tChPos( tChanMask, 2 ) ) + 1;tChY = tNGP - tChY + 1;% function toggleplot % toggle visibility of a particular data plot% if get( gcbo, 'Value' ) == 1 % plot button is depressed, make visible% set( get( gcbo, 'UserData'), 'Visible', 'On' );% else % plot button not depressed, make invisible% set( get( gcbo, 'UserData'), 'Visible', 'Off' );% endfunction rv = TScore( tX1, varargin ) % tX is NSamples x NChan x NSub, rv is NSamples x  NChanif( nargin == 1 )	% for testing hypothesis that mean of difference is zero	rv = nanmean( tX1, 3 ) ./ nanstd( tX1, 0, 3 ) .* sqrt( size( tX1, 3 ) );else % tX1 & tX2 are NSamples x NChan x NSub1 & x NSub2, rv is NSamples x  NChan	% heteroscedastic t-score for testing for testing hypothesis that difference of means is zero	tX2 = varargin{ 1 };	tN1 = size( tX1, 3 );	tN2 = size( tX2, 3 );	%			 |<----------------- this term is the variance ----------------------->|   |<--- div by n ---->|		tSEM = sqrt( ( tN1 * std( tX1, 0, 3 ) + tN2 * std( tX2, 0, 3 ) ) / ( tN1 + tN2 - 2 ) * ( 1 / tN1 + 1 / tN2 ) );	rv = ( mean( tX1, 3 ) - mean( tX2, 3 ) ) ./ tSEM;end% 	Special hack for GM to obtain record of NP P-values.  See PlotSig% 		tPVals = zeros( size( tTVDD ) );% 		tNSamp = size( tTVDD, 1 );% 		tNPerm = size( tRD, 1 );% 		for iSamp = 1:tNSamp% 			for iCh = 1:nCh% 				tPVals( iSamp, iCh ) = sum( tRD( :, iCh ) > tTVDD( iSamp, iCh ) ) / tNPerm;% 			end% 		end% 		save PVals tPVals; % 	End of hack% TO DO for reorganize significance testing functions% % Currently, both PlotSig and createreferencedistribution have a block of flow control logic statements% to handle the following state variables: Runs/Values, WInSubj/OneCnd/BWGrp.  The latter function also% handles permutation logic related to the latter state variable.% % Create StatScore function that can be shared by PlotSig and createreferencedistribution% Should handle Runs/Values, WInSubj/OneCnd/BWGrp so they can be ignored by higher% functions.  Should take an optional permutation index for building refdist.% Should implicitly handle spectral data using TCirc% % Create SetComparisonData function that creates the% temporary gMF fields to pass around the appropriate data for comparison % TO DO for spectral (tcirc) permutation test% make a function dof( n, aTcirc{y|n} ) to calculate dof with option for tcirc% TScore():	add argument to toggle for imaginary data% 			if(nargin == 2 ) ... else 3  end to handle new arg, making appropriate calls to dof% 			modify calls to TScore to include new argfunction rvStatScores = StatScores( aTRuns, aIndx )% Computes a matrix of rvStatScores statistical scores for the current comparison data stored in gMF.CmpData% aTRuns is a flag to toggle between score type: V(alues) or R(uns)% aIndx is a logical subscript matrix for permuting/recombining subjects during randomization tests% if left empty, scores for original, unrandomized data are returnedglobal gMF;if( iswinsubjcond | ( gMF.iCond1 == gMF.iCond2 ) )	% just one condition or winsbj difference condition means only one set of subjects	[ tNSamples tNChans tNSubs ] =  size( gMF.CmpData );	if( isempty( aIndx ) ) % we just want the unrandomized data		aIndx = ones( [ 1 1 tNSubs ] );	end	tSPM = reshape( 2 * aIndx - 1, [ 1 1 tNSubs ] ); % convert to a subject sign permutation matrix	if aTRuns == 'V' % TScores	 	rvStatScores = abs( TScore( gMF.CmpData .* repmat( tSPM, [tNSamples tNChans 1] ) ) );	else % aTRuns == 'R' % TRuns		rvStatScores = runsigtscore( gMF.CmpData .* repmat( tSPM, [tNSamples tNChans 1] ) );	endelse	% between group comparison; two groups of subjects are concatenated	if( isempty( aIndx ) ) % we just want the unrandomized data		% make a subject subscript vector with all ones for first group and all zeros for second group		aIndx = logical( [ ones( length( gMF.casSess{ gMF.iCond1 } ), 1 ); zeros( length( gMF.casSess{ gMF.iCond2 } ), 1 ) ] );	end	if aTRuns == 'V' % TScores	 	rvStatScores = abs( TScore( gMF.CmpData( :, :, aIndx ), gMF.CmpData( :, :, ~aIndx ) ) ); % use aIndx and ~aIndx to separate groups	else % aTRuns == 'R' % TRuns		rvStatScores = runsigtscore( gMF.CmpData( :, :, aIndx ), gMF.CmpData( :, :, ~aIndx ) );	endendfunction SetComparisonData( asDataType, aTRuns )% Creates a temporary gMF field to hold the appropriate data accessed by statistical comparison functionsglobal gMF;tR1 = getfield( gMF.Data{gMF.iCond1}, asDataType ); % asDataType toggles between .R (unnormalized) and .N (normalized)if( gMF.iCond2 ~= 0 )	tR2 = getfield( gMF.Data{gMF.iCond2}, asDataType );endif( iswinsubjcond | ( gMF.iCond1 == gMF.iCond2 ) )	if( gMF.iCond1 == gMF.iCond2 )		gMF.CmpData = tR1; % single condition v. zero	else		gMF.CmpData = tR2 - tR1; % difference potential for two conditions	endelse	gMF.CmpData = cat( 3, tR1, tR2 ); % between groupsendfunction ReCalcRefDist( asDataType, aTRuns )global gMF;tRD = createreferencedistribution( asDataType, aTRuns ); % tNPermutations x nCh x 1[ tNSamples, tNChans, tNSubs ] = size( getfield( gMF.Data{gMF.iCond1}, asDataType ) );tAlpha = 5; % default level is for suprathreshold cluster test, which is one-tailedif( aTRuns == 'V' )	tAlpha = 2.5; % for t-scores, it's two-tailedendtCritO = ones( tNSamples, tNChans ) * prctile( max( tRD, [], 2 ), 100 - tAlpha ); % Omnibus criterion matrixtCritC = repmat( prctile( tRD, 100 - tAlpha ), tNSamples, 1 ); % Chan-by-chan criterion maxtrixtSS = StatScores( aTRuns, [] );tSSSigIO = tSS > tCritO;tSSSigIC = tSS > tCritC;if( aTRuns == 'R' )	% for each run whose endpoint number, n, passes criterion, backfill the previous n	% elements in the significance index matrix.	for iCh = 1:tNChans		for iS = 1:tNSamples			if( tSSSigIO( iS, iCh ) )				tSSSigIO( ( iS - tSS( iS, iCh ) + 1 ):( iS-1 ), iCh ) = tSSSigIO( iS, iCh );			end			if( tSSSigIC( iS, iCh ) )				tSSSigIC( ( iS - tSS( iS, iCh ) + 1 ):( iS-1 ), iCh ) = tSSSigIC( iS, iCh );			end		end	endendtSigIndx = getfield( gMF, [ 'SigIndx' asDataType 'O' aTRuns ] );tSigIndx{gMF.iCond1, gMF.iCond2} = tSSSigIO; % fill in new matrix of sig diff indicestSigIndx{gMF.iCond2, gMF.iCond1} = tSigIndx{gMF.iCond1, gMF.iCond2}; % for symmetry, in case this pair of conditions is subsequently loaded in reverse ordergMF = setfield( gMF, [ 'SigIndx' asDataType 'O' aTRuns ], tSigIndx );tSigIndx = getfield( gMF, [ 'SigIndx' asDataType 'C' aTRuns ] );tSigIndx{gMF.iCond1, gMF.iCond2} = tSSSigIC; % fill in new matrix of sig diff indicestSigIndx{gMF.iCond2, gMF.iCond1} = tSigIndx{gMF.iCond1, gMF.iCond2}; % for symmetry, in case this pair of conditions is subsequently loaded in reverse ordergMF = setfield( gMF, [ 'SigIndx' asDataType 'C' aTRuns ], tSigIndx );