function [ tFilter, tFilterName ] = GetFilter( varargin )% [ tFilter tFilterName ] = GetFilter( iF, tNFr, tFilterName, tOrder )% v.1 = v.0 + ability to handle variable tOrder parameter (and, in general,% other parameters as well) through the magic of varargin.tFilters = { ...	'1f1'		'ParseFilterName'; ...	'1f2'		'ParseFilterName'; ...	'2f1'		'ParseFilterName'; ...	'2f2'		'ParseFilterName'; ...	'1f1+1f2'	'ParseFilterName'; ...	'nf1'		'CustomFilter'; ...	'nf2'		'CustomFilter'; ...	'f2band'	'CustomFilter'; ...	'nf1clean'	'CustomFilter'; ...	'nf2clean'	'CustomFilter'; ...	'nf1low15'	'CustomFilter'; ...	'nf1low10'	'CustomFilter'; ...	'rbtx-nf1'	'CustomFilter'; ...	'rbtx-nf2'	'CustomFilter'; ...	'rbtx-im'	'CustomFilter'; ...	'none'		'CustomFilter' ...};if nargin < 2	error( 'GetFilter requires first two args: iF, tNFr');	return;endif nargin == 2	[ iF, tNFr ] = deal( varargin{1:2} );	tFilterName = ChooseFilterFromList( iF, tNFr );	[ tFilter tFilterName ] = GetFilter( iF, tNFr, tFilterName );else	tFilterName = lower( varargin{ 3 } );	try		tiF = strmatch( tFilterName, tFilters( :, 1 ), 'exact' );% 		tFilter = tFilters{ tiF, 2 }( varargin{:} ); v.7 uses pointers		tFStr = 'tFilter = FILTERFUNCTION( varargin{:} );';		tFStr = strrep( tFStr, 'FILTERFUNCTION', tFilters{ tiF, 2 } );		eval( tFStr );	catch		if strmatch( tFilterName, 'getfilterlist', 'exact' )			tFilter = [];			tFilterName = tFilters( :, 1 );		else% 			msgbox( 'Unknown filter; Choose from following list...', 'modal' );			[ tFilter tFilterName ] = GetFilter( varargin{1:2} ); % will invoke ChooseFilterFromList		end	endend		function [ tFilter, tFilterName ] = ParseFilterName( varargin )% We use varargin for function handle conformity with CustomFilter[ iF, tNFr, tFN ] = deal( varargin{1:3} );tiF1 = str2num( tFN( findstr( 'f1', lower( tFN ) ) - 1 ) );if isempty( tiF1 )	tiF1 = 0;endtiF2 = str2num( tFN( findstr( 'f2', lower( tFN ) ) - 1 ) );if isempty( tiF2 )	tiF2 = 0;endtFilterCoefs = [ tiF1 tiF2 ];tFilter = sum( iF .* tFilterCoefs );tFilterName = tFN;function [ tFilter, tFilterName ] = CustomFilter( varargin )[ iF, tNFr, tFilterName ] = deal( varargin{1:3} );tOrder = 8;if nargin == 4	tOrder = varargin{ 4 };endswitch lower( tFilterName )	case 'nf1'		tFilter = [ iF(1):iF(1):( min( [ tNFr iF(1)*tOrder ] ) ) ]'; % eg., RBTX1: 1 2 3 4 8	case 'nf2'		tFilter = [ iF(2):iF(2):( min( [ tNFr iF(2)*tOrder ] ) ) ]';	case 'f2band'		t1F2 = GetFilter( iF, tNFr, '1f2' );		tNF1 = GetFilter( iF, tNFr, 'nf1', tOrder );		tFilter = t1F2 + [ -tNF1(end:-1:1); 0; tNF1(:) ];	case 'nf1clean'		tNF1 = GetFilter( iF, tNFr, 'nf1', floor( tNFr / iF(1) ) );		tNF2 = GetFilter( iF, tNFr, 'nf2', floor( tNFr / iF(2) ) );		tFilter = setxor( tNF1, intersect( tNF1, tNF2 ) );	case 'nf2clean'		tNF1 = GetFilter( iF, tNFr, 'nf1', floor( tNFr / iF(1) ) );		tNF2 = GetFilter( iF, tNFr, 'nf2', floor( tNFr / iF(2) ) );		tFilter = setxor( tNF2, intersect( tNF1, tNF2 ) );	case 'nf1low15'		% low pass version of nf1; nF2 and IM terms are not removed.		% Only intended for conditions with low global/noise		% frequency and high update frequencies.		% Hard-coded cut at 15Hz if f1 = 1Hz...		tFilter = GetFilter( iF, tNFr, 'nf1', 15 );	case 'nf1low10'		% Hard-coded cut at 10Hz if f1 = 1Hz...		tFilter = GetFilter( iF, tNFr, 'nf1', 10 );	case 'rbtx-nf1'		tFilter = iF(1) * [ 1 2 3 4 8 ]';	case 'rbtx-nf2'		tFilter = iF(2) * [ 1 2 3 4 8 ]';	case 'rbtx-im'		tCoeffs = [ 2 -1; -1 2; 3 -1; 1 1; -1 3; 2 1; 1 2; 1 3; 2 2; 1 3 ];		tFilter = sum( tCoeffs .* repmat( iF, size( tCoeffs, 1 ), 1 ), 2 );	case 'none'		tFilter = [ 1:tNFr ]'; % eg., RBTX1: 1 2 3 4 8	otherwise		error( 'Unknown filter name' );endfunction tFilterName = ChooseFilterFromList( iF, tNFr )[ tFilter tFiltNames ] = GetFilter( iF, tNFr, 'getfilterlist' );tFilterName = tFiltNames{ ...	listdlg( 'ListString', tFiltNames, 'SelectionMode', 'single', 'PromptString', 'Choose a filter' ) };