function fastrandtest( tR )% load fakedata;[ tNSamp, tNCh, tNSubj ] = size( tR );% figure; plot( squeeze( tR( 1:tNSamp, 1, : ) ) )% hold on; plot( [ 1:tNSamp ], mean( tR( 1:tNSamp, 1, : ), 3 ), 'c-', 'linewidth', 3 )tNSamCh = tNSamp * tNCh;tR = reshape( tR, tNSamCh, tNSubj );  tTScore = mean( tR, 2 ) ./ std( tR, 0, 2 ) .* sqrt( tNSubj );tRAbs = abs( tR );tTScoreAbs = mean( tRAbs, 2 ) ./ std( tRAbs, 0, 2 ) .* sqrt( tNSubj );% convert binary representation of sign permutation to realize tRAbs into integertPermInt = bits2num( tR == tRAbs ); % create matrix of tscores and permints for the tNSubj permutations that are abs except for one elementtTScoreAbs1 = zeros( tNSamCh, tNSubj );tPermInt1 = zeros( tNSamCh, tNSubj );for iAbs1 = 1:tNSubj	tRAbs1 = tRAbs;	tRAbs1( :, iAbs1 ) = tRAbs1( :, iAbs1 ) * -1;	tPermInt1( :, iAbs1 ) = bits2num( tR == tRAbs1 ); 	tTScoreAbs1( :, iAbs1 ) = mean( tRAbs1, 2 ) ./ std( tRAbs1, 0, 2 ) .* sqrt( tNSubj );end% now collapse these into vectors for the max tscore across each subject at each time pointtPermInt1 = max( tPermInt1 .* ( tTScoreAbs1 == repmat( max( tTScoreAbs1, [], 2 ), 1, tNSubj ) ), [], 2 );tTScoreAbs1 = max( tTScoreAbs1, [], 2 );tTSAMx1 = max( tTScoreAbs1 );tNExt = floor( 2 ^ tNSubj * 0.025 ); % number of extrema, i.e. permutations in 2.5% tails of all permutationstExt = zeros( tNExt, 1 ); % for debugging% tExt1 = zeros( tNExt, 1 ); % for debuggingfor iExt = 1:tNExt	[ tMaxTSA, iMaxTSA ] = max( tTScoreAbs ); % the current tMaxTSA, and it's index	[ tMaxTSA1, iMaxTSA1 ] = max( tTScoreAbs1 ); % the current tMaxTSA, and it's index	tExt( iExt ) = tMaxTSA;% 	tExt1( iExt ) = tMaxTSA1;	% all time points with the same permutation as the current maximum tscore must be removed...	if( tMaxTSA > tMaxTSA1 )		tTScoreAbs(	tPermInt == tPermInt( iMaxTSA ) ) = 0;		tTScoreAbs1( tPermInt1 == tPermInt( iMaxTSA ) ) = 0;		tExt( iExt ) = tMaxTSA;	else		tTScoreAbs(	tPermInt == tPermInt1( iMaxTSA1 ) ) = 0;		tTScoreAbs1( tPermInt1 == tPermInt1( iMaxTSA1 ) ) = 0;		tExt( iExt ) = tMaxTSA1;	end	if( sum( tTScoreAbs ) == 0 | sum( tTScoreAbs1 ) == 0 )		break;	endendassignin( 'base', 'tExt', tExt );assignin( 'base', 'tPermInt', tPermInt );tCV = tExt( iExt ); % the critical value from tTScoreAbs extrema onlyfigure;tT = [ 1:tNSamp ]';for iCh = 1:tNCh	tCI = tT + ( iCh - 1 ) * tNSamp; % current indices into data for this channel 	subplot( tNCh, 1, iCh );	hold on;	plot( tT, tR( tCI, : ), 'm-' )	tRM = mean( tR( tCI, : ), 2 );	plot( tT, tRM, 'c-', 'linewidth', 3 );	tTSI = abs( tTScore( tCI ) ) > tCV;	plot( tT( tTSI ), tRM( tTSI ), 'k.', 'markersize', 9 );	axis tight;endtH = allchild( gcf );tPos = get( tH, 'position' );tPos = cat( 1, tPos{:} );tYLim = get( tH, 'ylim' );tYLim = cat( 1, tYLim{:} );tYLim = [ min( tYLim( :, 1 ) ) max( tYLim( :, 2 ) ) ];for iCh = 1:tNCh	set( tH( iCh ), 'position', tPos( iCh, : ) + [ 0, -0.01, 0, 0.02 ], 'ylim', tYLim );endfunction tR = bits2num( tX )[ tNR, tNC ] = size( tX );tR = sum( ones( tNR, 1 ) * pow2( [ (tNC-1):-1:0 ] ) .* tX, 2 ); function tR = onescomp( tV, tNB )tV = tV(:); % tV(:) makes it a column vectortR = sum( ones( length( tV ), 1 ) * pow2( [ (tNB-1):-1:0 ] ) .* ~num2bits( tV, tNB ), 2 );% what kind of works% any( tTScoreAbs1( tPermInt == tPermInt( iMaxTSA ) ) == tMaxTSA1 ) hits the first two interlopers% what doesn't work% simply interlacing tExt and tExt1% cutting out both tTScoreAbs matrices on each pass through% moving tTScoreAbs1 into tTScoreAbs 