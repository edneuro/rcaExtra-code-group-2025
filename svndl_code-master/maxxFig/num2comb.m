function rC = num2comb( aV, aNG, aNS )% Parse the vector aV into a matrix of bitfields, rC, representing unique combinations% of a group of aNG subjects taken from aNS subjects.  Each element of aV must be in the% range [ 1:tNCT ] where tNCT is the total number of possible combinations.% Reasonably fast -- does about 1000 values per second.tNV = length( aV );rC = zeros( tNV, aNS );for iV = 1:tNV	rC( iV, : ) = num2comb_val( aV( iV ), aNG, aNS ); % call the helper functionendfunction rC = num2comb_val( aV, aNG, aNS )% helper function for num2comb to do the heavy liftingtNCR = prod( (aNS - aNG + 1):aNS ) / prod( 1:aNG ); % number of combinations remainingtNGR = aNG; % number of group slots remaining to be assignedtNSR = aNS; % number of subjects remaining% Among the remaining combinations, how many have the first subject true?% this is simply the probability of any given subject being true given the% remaining numbers of group slots and subjects, times the total number of% remaining combinations.  If a subject is "true", s/he is in the group.tNCT = tNGR / tNSR * tNCR;tNCF = tNCR - tNCT; % how many are false?rC = zeros( 1, aNS ); % the bitfield of the result combination, default zerotV = aV; % copy of argument to parsefor iS = 1:aNS % an index indicating the current subject	% is the current value above the range of combinations where the current subject is true?	if( tV > tNCT ) % the current subject is false, implicity keep the default zero bit		% number of combinations remaining is now those where the current subject is false		tNCR = tNCF;		% find remainder of tV after skipping over combinations where current subject is true		tV = tV - tNCT;	else		rC( iS ) = 1; % the current subject is true, set the corresponding bit		% number of combinations remaining is now those where the current subject is true		tNCR = tNCT; 		tNGR = tNGR - 1; % number of group slots remaining to be assigned		if( tNGR == 0 )			break;		end	end	tNSR = tNSR - 1; % number of subjects remaining	% Among the remaining combinations, how many have the next subject true?	tNCT = tNGR / tNSR * tNCR;	tNCF = tNCR - tNCT; % how many are false?end% function rB = num2bits( aV, aN )% tV = aV(:); % Make sure v is a row vector.% tNV = length( tV ); % number of numbers to convert% rB = zeros( tNV, aN );% tP = aN - 1;% rB( :, 1 ) = mod( tV, ( 2 ^ aN ) );% for iP = 1:( aN - 1 )% 	rB( :, iP+1 ) = mod( rB( :, iP ), ( 2 ^ tP ) );% 	rB( :, iP ) = floor( rB( :, iP ) / ( 2 ^ tP ) );% 	tP = tP - 1;% end% rB( :, end ) = floor( rB( :, end ) / ( 2 ^ tP ) );